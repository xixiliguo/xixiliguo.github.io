(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[834],{4747:(n,a,e)=>{"use strict";e.r(a),e.d(a,{data:()=>t});const t={key:"v-ed478086",path:"/linux/cloud-init.html",title:"cloud-init学习笔记",lang:"en-US",frontmatter:{title:"cloud-init学习笔记",author:"Peter Wang",tags:["cloud-init","Python","OpenStack"],date:"2017-10-18T13:34:09.000Z",draft:!1},excerpt:"",headers:[{level:2,title:"cloud-init介绍",slug:"cloud-init介绍",children:[]},{level:2,title:"基本概念和相关文件目录",slug:"基本概念和相关文件目录",children:[{level:3,title:"datasources",slug:"datasources",children:[]},{level:3,title:"userdata",slug:"userdata",children:[]},{level:3,title:"metadata",slug:"metadata",children:[]},{level:3,title:"stage",slug:"stage",children:[]},{level:3,title:"modules",slug:"modules",children:[]},{level:3,title:"handlers",slug:"handlers",children:[]},{level:3,title:"frequencies",slug:"frequencies",children:[]},{level:3,title:"/var/lib/cloud/目录解读",slug:"var-lib-cloud-目录解读",children:[]}]},{level:2,title:"工作原理",slug:"工作原理",children:[{level:3,title:"local 阶段",slug:"local-阶段",children:[]},{level:3,title:"network 阶段",slug:"network-阶段",children:[]},{level:3,title:"config 阶段",slug:"config-阶段",children:[]},{level:3,title:"final 阶段",slug:"final-阶段",children:[]}]},{level:2,title:"cloud-init 源码结构",slug:"cloud-init-源码结构",children:[]},{level:2,title:"运行的主入口",slug:"运行的主入口",children:[]},{level:2,title:"常见模板介绍",slug:"常见模板介绍",children:[{level:3,title:"cc_set_hostname.py",slug:"cc-set-hostname-py",children:[]},{level:3,title:"cc_update_hostname.py",slug:"cc-update-hostname-py",children:[]},{level:3,title:"cc_growpart.py",slug:"cc-growpart-py",children:[]},{level:3,title:"cc_resizefs.py",slug:"cc-resizefs-py",children:[]}]},{level:2,title:"数据源实现",slug:"数据源实现",children:[]},{level:2,title:"配置文件",slug:"配置文件",children:[]}],filePathRelative:"linux/cloud-init.md",git:{updatedTime:1626591395e3,contributors:[]}}},9529:(n,a,e)=>{"use strict";e.r(a),e.d(a,{default:()=>s});const t=(0,e(6252).uE)('<h2 id="cloud-init介绍" tabindex="-1"><a class="header-anchor" href="#cloud-init介绍" aria-hidden="true">#</a> cloud-init介绍</h2><p>目前大部分公有云（openstack, AWS, Aliyun）都在使用cloud-init, 已经成为虚拟机元数据管理和OS系统配置初始化的事实标准.最早cloud-init由ubuntu的母公司 Canonical 开发。主要思想是当用户首次创建虚拟机时，将前台设置的主机名，密码或者秘钥等存入metadata server(顾名思义，存放元数据的服务器）。在openstack环境下当cloud-init随虚拟机启动而运行时，通过http协议访问metadata server，获取这些信息并修改主机配置。完成系统的环境初始化。本文以openstack + centos7 + cloud-init 0.7.9 为例,分两篇介绍基本概念，工作原理和源码解读。</p><p>如下是一些cloud-init的关键信息：<br> 源码： https://github.com/cloud-init/cloud-init<br> 文档： https://cloudinit.readthedocs.io/en/latest/<br> 配置文件： /etc/cloud/cloud.cfg<br> 日志：/var/log/cloud-init.log<br> 存放关键数据的目录： /var/lib/cloud/</p><h2 id="基本概念和相关文件目录" tabindex="-1"><a class="header-anchor" href="#基本概念和相关文件目录" aria-hidden="true">#</a> 基本概念和相关文件目录</h2><h3 id="datasources" tabindex="-1"><a class="header-anchor" href="#datasources" aria-hidden="true">#</a> datasources</h3><p>cloud-init将openstack, AWS, Aliyun等众多云平台抽象成数据源，使用统一的接口适配所有平台。<br> 具体地，openstack下获取数据的方法是访问http://169.254.169.254 下的 userdata和metadata</p><h3 id="userdata" tabindex="-1"><a class="header-anchor" href="#userdata" aria-hidden="true">#</a> userdata</h3><p>可以是文件，shell脚本或者cloud-init配置文件。租户可以在前台输入。<br> 具体的格式,请参考<br> https://cloudinit.readthedocs.io/en/latest/topics/format.html<br> 如下是一个shell脚本的userdata, openstack下用它来初始化root用户的密码</p><div class="language-text ext-text"><pre class="language-text"><code>[root@ecs-test-wangbo log]# curl http://169.254.169.254/openstack/2015-10-15/user_data\n#!/bin/bash\necho &#39;root:$6$O9wyDQ$LYGAz6V/dy66Ve8eJkeATAbXOwjkWGpLbr4QoxkH8iQ0nsLa7.n3lzSlOer7Okb2RD8FObkP3RRPHEKS2xGip0&#39; | chpasswd -e;\n</code></pre></div><h3 id="metadata" tabindex="-1"><a class="header-anchor" href="#metadata" aria-hidden="true">#</a> metadata</h3><p>包含主机名，实例id和其他服务器相关的信息</p><div class="language-text ext-text"><pre class="language-text"><code>[root@ecs-test-wangbo log]# curl http://169.254.169.254/openstack/2015-10-15/meta_data.json | python -m json.tool\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100  1297  100  1297    0     0   2452      0 --:--:-- --:--:-- --:--:--  2456\n{\n    &quot;availability_zone&quot;: &quot;cn-east-2a&quot;,\n    &quot;hostname&quot;: &quot;ecs-test-wangbo.novalocal&quot;,\n    &quot;launch_index&quot;: 0,\n    &quot;meta&quot;: {\n        &quot;charging_mode&quot;: &quot;0&quot;,\n        &quot;image_name&quot;: &quot;CentOS 7.3 64bit&quot;,\n        &quot;metering.cloudServiceType&quot;: &quot;hws.service.type.ec2&quot;,\n        &quot;metering.image_id&quot;: &quot;643d831d-a69c-433f-803f-065e0e2e2911&quot;,\n        &quot;metering.imagetype&quot;: &quot;gold&quot;,\n        &quot;metering.resourcespeccode&quot;: &quot;c1.medium.linux&quot;,\n        &quot;metering.resourcetype&quot;: &quot;1&quot;,\n        &quot;os_bit&quot;: &quot;64&quot;,\n        &quot;os_type&quot;: &quot;Linux&quot;,\n        &quot;vpc_id&quot;: &quot;8428b86b-7ec1-4b31-97aa-d6a0db2c3aab&quot;\n    },\n    &quot;name&quot;: &quot;ecs-test-wangbo&quot;,\n    &quot;project_id&quot;: &quot;9b4e13cdeb7c4c6ebb929a4a503e51a2&quot;,\n    &quot;random_seed&quot;: &quot;zUPkPLRFdLufLlYMnqQcrcp/nob7nJecOH/Nsv+hjDcNz1oYLvW/6qHgbL/++Kqvt0DLbkgpxRCO+lnqZfdOMadnZUHabdzB5LjEqOBFnk22RewmAh2sITOD1QPqmsvEssAOlz39FrUtK7+0XHIFclwYZIk8XtXPQa9L1lM9v76Y3+cZI18m1V0E+He1qLQzfyfu4qYYc8ER4YcGS2T2L/cZIRT9o20vwrLO7Ut2d98uitHhUphfVMVANG2DkZDK3U4DgR4M8q7jFMl5a3oR370XVYS7XqAn8YopCFXH1wAKCzipbzVL+JXiq9W6xFNvDvnK+bKdMVHf7ge+zUmRG6LnPpBqFLUT03qyhrErTLrV6mjpw3u4+uAX/Okn8NoWB0eEqly/VSgR3eAF4v/Ga2GylUSRCXcHH5Ss0RvbcXmF0NeGcMKH1QueBd9wBRxygBJsXZS0ZKfd+T13cA22TwqWLw4UFj3gu08/NE51A9sZu9quM6HL+XWOdqcOtN1T3aJVp6w2uisAfJCNEVq7Ftr2k0SsJdVHWw6dseDc3kOCC0Q+JPZh8deGF28/v+dykZH7yyHhFZCQZqHGarrd+QPwTzc3mdzzV/BL+GeNbYXKQXf6Uibv5s9usI6QwF+sfOg6AKtyUICWTDGgKRL1FUaDR3zF4sGIftO0AZ49vhI=&quot;,\n    &quot;uuid&quot;: &quot;e9f15094-8157-4c78-96a1-674cbaf26baf&quot;\n}\n</code></pre></div><h3 id="stage" tabindex="-1"><a class="header-anchor" href="#stage" aria-hidden="true">#</a> stage</h3><p>cloud-init对系统的配置分为四个阶段， 内部叫stage。 分别是local, network,config, final</p><h3 id="modules" tabindex="-1"><a class="header-anchor" href="#modules" aria-hidden="true">#</a> modules</h3><p>具体的定制化配置是由模块完成。每个模块根据获取的元数据和配置文件完成相关配置<br> cloud.cfg里的部分配置：</p><div class="language-yaml ext-yml"><pre class="language-yaml"><code><span class="token key atrule">cloud_init_modules</span><span class="token punctuation">:</span>  // 定义init阶段需要执行的模块\n <span class="token punctuation">-</span> migrator          // 迁移老的cloud<span class="token punctuation">-</span>init数据为新的\n <span class="token punctuation">-</span> bootcmd           // 启动时执行相关命令 \n <span class="token punctuation">-</span> write<span class="token punctuation">-</span>files       // 根据cloud.cfg的配置写数据到文件里\n <span class="token punctuation">-</span> growpart          // 扩展分区到硬盘的大小 ，默认对根分区执行。 它需要调用“growpart”或者”gpart“\n <span class="token punctuation">-</span> resizefs          // resize文件系统，适配新的大小。 默认对根目录执行\n <span class="token punctuation">-</span> set_hostname      // 根据元数据设置主机名\n <span class="token punctuation">-</span> update_hostname   // 更新主机名，适用于当用户自定义主机名时\n <span class="token punctuation">-</span> update_etc_hosts  \n <span class="token punctuation">-</span> rsyslog\n <span class="token punctuation">-</span> users<span class="token punctuation">-</span>groups      // 根据cloud.cfg的配置创建用户组和用户\n <span class="token punctuation">-</span> ssh               // 配置sshd\n</code></pre></div><h3 id="handlers" tabindex="-1"><a class="header-anchor" href="#handlers" aria-hidden="true">#</a> handlers</h3><p>用于具体处理userdata.目前有四类默认的handler： boot hook， cloud config ，shell script， upstart job</p><h3 id="frequencies" tabindex="-1"><a class="header-anchor" href="#frequencies" aria-hidden="true">#</a> frequencies</h3><p>handler/module的运行频率， 目前有三个有效值:<br> once-per-instance<br> always<br> once</p><h3 id="var-lib-cloud-目录解读" tabindex="-1"><a class="header-anchor" href="#var-lib-cloud-目录解读" aria-hidden="true">#</a> /var/lib/cloud/目录解读</h3><p>该目录主要保存元数据和其他一些运行时需要的信息</p><p>/var/lib/cloud/data 文件夹存放具体的数据源，主机名和实例ID<br> result.json 记录了一些数据源信息<br> status.json 记录了每个stage运行的开始时间，结束时间和遇到的error</p><div class="language-text ext-text"><pre class="language-text"><code>/var/lib/cloud/data\n├── instance-id\n├── previous-datasource\n├── previous-hostname\n├── previous-instance-id\n├── result.json\n└── status.json\n</code></pre></div><p>/var/lib/cloud/instance 存放元数据和其他一些缓存文件</p><div class="language-text ext-text"><pre class="language-text"><code>/var/lib/cloud/instance\n├── boot-finished         // 记录cloud-ini运行完的时间\n├── cloud-config.txt\n├── datasource        \n├── handlers\n├── obj.pkl              // 缓存文件\n├── scripts\n│   └── part-001         // userdata为shell脚本，解析后归档到此\n├── sem                  // 该目录用来存放各模块执行时的锁文件\n├── user-data.txt        // 从数据源获取的user-data\n├── user-data.txt.i\n├── vendor-data.txt\n└── vendor-data.txt.i\n</code></pre></div><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2><p>前面提到cloudinit分四个阶段执行，具体它们以服务的形式注册到系统中按如下顺序依次运行:<br> local - cloud-init-local.service<br> nework - cloud-init.service<br> config - cloud-config.service<br> final - cloud-final.service<br> 每个具体的服务中对应的命令如下，都只运行一次，没有常驻进程<br> 可以看到执行的都是 /usr/bin/cloud-init这个文件，但参数不一样<br> 所有debug日志全部默认输出到/var/log/cloud-init.log</p><div class="language-text ext-text"><pre class="language-text"><code>[root@ecs-test-wangbo ~]# grep ExecStart /lib/systemd/system/cloud-*.service\n/lib/systemd/system/cloud-config.service:ExecStart=/usr/bin/cloud-init modules --mode=config\n/lib/systemd/system/cloud-final.service:ExecStart=/usr/bin/cloud-init modules --mode=final\n/lib/systemd/system/cloud-init-local.service:ExecStart=/usr/bin/cloud-init init --local\n/lib/systemd/system/cloud-init-local.service:ExecStart=/bin/touch /run/cloud-init/network-config-ready\n/lib/systemd/system/cloud-init.service:ExecStart=/usr/bin/cloud-init init\n[root@ecs-test-wangbo ~]# \n\n[root@ecs-test-wangbo ~]# grep &quot;Cloud-init v. 0.7.9 running&quot; /var/log/cloud-init.log \n2017-10-18 09:57:50,309 - util.py[DEBUG]: Cloud-init v. 0.7.9 running &#39;init-local&#39; at Wed, 18 Oct 2017 01:57:50 +0000. Up 9.28 seconds.\n2017-10-18 09:57:56,036 - util.py[DEBUG]: Cloud-init v. 0.7.9 running &#39;init&#39; at Wed, 18 Oct 2017 01:57:56 +0000. Up 15.03 seconds.\n2017-10-18 09:58:43,771 - util.py[DEBUG]: Cloud-init v. 0.7.9 running &#39;modules:config&#39; at Wed, 18 Oct 2017 01:58:43 +0000. Up 62.72 seconds.\n2017-10-18 09:58:44,165 - util.py[DEBUG]: Cloud-init v. 0.7.9 running &#39;modules:final&#39; at Wed, 18 Oct 2017 01:58:44 +0000. Up 63.11 seconds.\n[root@ecs-test-wangbo ~]# \n</code></pre></div><h3 id="local-阶段" tabindex="-1"><a class="header-anchor" href="#local-阶段" aria-hidden="true">#</a> local 阶段</h3><p>此时 instance 尝试从ConfigDrive等本地源获取信息。在openstack环境下是不存在的，然后cloud-init 检查系统是否有默认网卡，有则配置为dhcp, 并写入 /etc/sysconfig/network-scripts/ifcfg-eth0. 只有配置了dhcp, 该网卡有了ip, 才能进一步连接metadataserver获取元数据 因为使用了dhcp, 所有也会从dhcp server获取dns配置并写入/etc/resolv.conf。 这个和vpc里配置的dns服务器是一致的</p><div class="language-text ext-text"><pre class="language-text"><code>2017-10-18 09:57:50,500 - main.py[DEBUG]: No local datasource found\n2017-10-18 09:57:50,500 - util.py[DEBUG]: Reading from /sys/class/net/eth0/carrier (quiet=False)\n2017-10-18 09:57:50,500 - util.py[DEBUG]: Reading from /sys/class/net/eth0/dormant (quiet=False)\n2017-10-18 09:57:50,500 - util.py[DEBUG]: Reading from /sys/class/net/eth0/operstate (quiet=False)\n2017-10-18 09:57:50,500 - util.py[DEBUG]: Read 5 bytes from /sys/class/net/eth0/operstate\n2017-10-18 09:57:50,500 - util.py[DEBUG]: Reading from /sys/class/net/eth0/address (quiet=False)\n2017-10-18 09:57:50,501 - util.py[DEBUG]: Read 18 bytes from /sys/class/net/eth0/address\n2017-10-18 09:57:50,501 - stages.py[DEBUG]: applying net config names for {&#39;version&#39;: 1, &#39;config&#39;: [{&#39;subnets&#39;: [{&#39;type&#39;: &#39;dhcp&#39;}], &#39;type&#39;: &#39;physical&#39;, &#39;name&#39;: &#39;eth0&#39;, &#39;mac_address&#39;: &#39;fa:16:3e:b0:e3:5d&#39;}]}\n</code></pre></div><h3 id="network-阶段" tabindex="-1"><a class="header-anchor" href="#network-阶段" aria-hidden="true">#</a> network 阶段</h3><p>此时 instance 已经有自己的ip, 然后搜索所有网路源如下</p><div class="language-text ext-text"><pre class="language-text"><code>2017-10-18 09:57:56,102 - __init__.py[DEBUG]: Searching for network data source in: [u&#39;DataSourceNoCloudNet&#39;, u&#39;DataSourceAzureNet&#39;, u&#39;DataSourceAltCloud&#39;, u&#39;DataSourceOVFNet&#39;, u&#39;DataSourceMAAS&#39;, u&#39;DataSourceGCE&#39;, u&#39;DataSourceOpenStack&#39;, u&#39;DataSourceEc2&#39;, u&#39;DataSourceCloudStack&#39;, u&#39;DataSourceBigstep&#39;, u&#39;DataSourceNone&#39;]\n</code></pre></div><p>最终通过访问 169.254.169.254成功获取openstack下的数据,</p><div class="language-text ext-text"><pre class="language-text"><code>2017-10-18 09:58:31,288 - __init__.py[DEBUG]: Seeing if we can get any data from &lt;class &#39;cloudinit.sources.DataSourceOpenStack.DataSourceOpenStack&#39;&gt;\n2017-10-18 09:58:31,289 - url_helper.py[DEBUG]: [0/1] open &#39;http://169.254.169.254/openstack&#39; with {&#39;url&#39;: &#39;http://169.254.169.254/openstack&#39;, &#39;headers&#39;: {&#39;User-Agent&#39;: &#39;Cloud-Init/0.7.9&#39;}, &#39;allow_redirects&#39;: True, &#39;method&#39;: &#39;GET&#39;, &#39;timeout&#39;: 10.0} configuration\n2017-10-18 09:58:31,952 - url_helper.py[DEBUG]: Read from http://169.254.169.254/openstack (200, 50b) after 1 attempts\n2017-10-18 09:58:31,952 - DataSourceOpenStack.py[DEBUG]: Using metadata source: &#39;http://169.254.169.254\n</code></pre></div><p>下面日志表明抓取数据成功，并写入<code>/var/lib/cloud/instances/e9f15094-8157-4c78-96a1-674cbaf26baf</code></p><div class="language-text ext-text"><pre class="language-text"><code>2017-10-18 09:58:43,120 - util.py[DEBUG]: Crawl of openstack metadata service took 11.168 seconds\n</code></pre></div><p>其他步骤如下:</p><ol><li>解析userdata,并执行</li><li>按cloud.cfg里的配置顺序，依次运行各模块</li></ol><h3 id="config-阶段" tabindex="-1"><a class="header-anchor" href="#config-阶段" aria-hidden="true">#</a> config 阶段</h3><p>执行一些配置模块。</p><h3 id="final-阶段" tabindex="-1"><a class="header-anchor" href="#final-阶段" aria-hidden="true">#</a> final 阶段</h3><p>此时大部分定制化已经完成， 这里只是一些简单的收尾工作 比如 final-message 模块，只是在日志里打印cloud-init启动结束</p><div class="language-text ext-text"><pre class="language-text"><code>2017-10-18 09:58:44,236 - handlers.py[DEBUG]: start: modules-final/config-final-message: running config-final-message with frequency always\n2017-10-18 09:58:44,236 - helpers.py[DEBUG]: Running config-final-message using lock (&lt;cloudinit.helpers.DummyLock object at 0x1c81750&gt;)\n2017-10-18 09:58:44,236 - util.py[DEBUG]: Reading from /proc/uptime (quiet=False)\n2017-10-18 09:58:44,236 - util.py[DEBUG]: Read 12 bytes from /proc/uptime\n2017-10-18 09:58:44,240 - util.py[DEBUG]: Cloud-init v. 0.7.9 finished at Wed, 18 Oct 2017 01:58:44 +0000. Datasource DataSourceOpenStack [net,ver=2].  Up 63.25 seconds\n2017-10-18 09:58:44,240 - util.py[DEBUG]: Writing to /var/lib/cloud/instance/boot-finished - wb: [420] 51 bytes\n2017-10-18 09:58:44,241 - handlers.py[DEBUG]: finish: modules-final/config-final-message: SUCCESS: config-final-message ran successfully\n</code></pre></div><h2 id="cloud-init-源码结构" tabindex="-1"><a class="header-anchor" href="#cloud-init-源码结构" aria-hidden="true">#</a> cloud-init 源码结构</h2><p>大部分代码存放于 /lib/python2.7/site-packages/cloudinit</p><div class="language-text ext-text"><pre class="language-text"><code>├── cmd                   // 所有命令的主入口\n├── config                // 各种模块文件\n├── distros               // 各OS具体操作实现（比如安装软件，写文件）\n│   └── parsers\n├── filters               // 日志相关的过滤\n├── handlers              // 处理userdata的具体实现\n├── mergers               // 辅助函数\n├── net                   // 网络配置的通用操作 \n├── reporting             // 通用的类，用于报告各种事件\n└── sources               // openstack, aliyun等数据源的类实现\n    └── helpers\n        └── vmware\n            └── imc\n</code></pre></div><h2 id="运行的主入口" tabindex="-1"><a class="header-anchor" href="#运行的主入口" aria-hidden="true">#</a> 运行的主入口</h2><p>local, network, config, final三个不同阶段通过不同的参数，传递给主程序.比如local的具体命令行为 <code>/usr/bin/cloud-init init --local</code>.首先主入口是 <code>cmd/main.py</code>, 解析命令行参数</p><div class="language-python ext-py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>sysv_args<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">if</span> sysv_args <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>\n        parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>prog<span class="token operator">=</span>sysv_args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n        sysv_args <span class="token operator">=</span> sysv_args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>\n    <span class="token keyword">else</span><span class="token punctuation">:</span>\n        parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>local, init会走入 <code>main_init</code>这个函数， local主要是寻找本地源（比如configdriver）, init阶段是寻找网络源（比如通过http消息获取metadata）</p><p>当前华为云的裸金属镜像使用configdriver这种方式，原理如下：</p><blockquote><p>物理机启动minios, 下载镜像和metadata<br> 给一块硬盘分区，将镜像dd写入第一分区<br> 在该硬盘的最后位置，生成一个分区，写入metadata<br> minios重启系统，让物理机从新的硬盘引导<br> OS启动后，里面的cloud-init会挂载分区 /dev/sr0类似这样的<br> mount后将读取普通文件一样获取metadata</p></blockquote><p><code>main_init</code>主要做的事情如下：</p><ol><li>读取配置文件</li><li>初始化日志信息</li><li>根据配置初始化运行时相关的目录和权限</li><li>如果是寻找网络源的过程，检查是否已经存在信息，有则提前退出，无则继续第五步</li><li>根据当前Cloud-init所支持的datasource列表， 逐个搜索，看是否可以获取元数据。 所有全部数据源都检查后没有找到数据且命令行没有设置 <code>--force</code>， cloud-init会提前推出， 否则继续第六步。</li><li>配置网络， local阶段会自动设置eth0为dhcp模式，用自动获取ip, 这样在init阶段（有时也叫network）时网络源才能正常工作。</li><li>如果元数据里有userdata, 则程序开始解析并运行</li><li>重读配置文件，获取该阶段需要运行的模块</li><li>根据待运行的模块重新配置日志输出</li><li>执行8步获取的模块列表</li></ol><h2 id="常见模板介绍" tabindex="-1"><a class="header-anchor" href="#常见模板介绍" aria-hidden="true">#</a> 常见模板介绍</h2><p>config文件下包含所有模块，通过名字很容易识别其对应的功能。 比如 <code>cc_set_hostname.py</code> 用于创建虚拟机时设置主机名。 ``cc_update_hostname.py`用于每次启动时更新主机名。 模块都根据对应的配置项执行， 同时每个模块有自己固定的运行频率（per isntance, per always等）</p><h3 id="cc-set-hostname-py" tabindex="-1"><a class="header-anchor" href="#cc-set-hostname-py" aria-hidden="true">#</a> cc_set_hostname.py</h3><p>只在创建虚拟机时运行一次， 如果perserve_hostname为false, 则模块不运行。 从metadata里提取hostname, 然后运行对应OS下的设置主机名命令</p><h3 id="cc-update-hostname-py" tabindex="-1"><a class="header-anchor" href="#cc-update-hostname-py" aria-hidden="true">#</a> cc_update_hostname.py</h3><p>每次虚拟机重启都会运行一次（包括第一次新建虚拟机）， 如果perserve_hostname为true, 则模块不运行。</p><ol><li>首先检查是否存在/var/lib/cloud/data/previous-hostname文件，有则对比当前OS的主机名， 如果不一样认为管理员维护主机名。提前退出</li><li>发现当前元数据和当前OS的主机名不一样，则直接更新</li><li>将最新的主机名写入 previous-hostname</li></ol><h3 id="cc-growpart-py" tabindex="-1"><a class="header-anchor" href="#cc-growpart-py" aria-hidden="true">#</a> cc_growpart.py</h3><p>每次虚拟机重启都会运行一次（包括第一次新建虚拟机）， 它会调整分区， 实现自动扩容，默认对根盘所有的虚拟磁盘执行。若要正常工作，还需要安装cloud-utils-growpart等辅助软件包</p><h3 id="cc-resizefs-py" tabindex="-1"><a class="header-anchor" href="#cc-resizefs-py" aria-hidden="true">#</a> cc_resizefs.py</h3><p>每次虚拟机重启都会运行一次（包括第一次新建虚拟机）, 它主要配置growpart, 对文件系统扩容。 growpart主要针对磁盘。 不同的文件系统，调用不同的命令</p><div class="language-python ext-py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">_resize_btrfs</span><span class="token punctuation">(</span>mount_point<span class="token punctuation">,</span> devpth<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">&#39;btrfs&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;filesystem&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;resize&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;max&#39;</span><span class="token punctuation">,</span> mount_point<span class="token punctuation">)</span>\n\n\n<span class="token keyword">def</span> <span class="token function">_resize_ext</span><span class="token punctuation">(</span>mount_point<span class="token punctuation">,</span> devpth<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">&#39;resize2fs&#39;</span><span class="token punctuation">,</span> devpth<span class="token punctuation">)</span>\n\n\n<span class="token keyword">def</span> <span class="token function">_resize_xfs</span><span class="token punctuation">(</span>mount_point<span class="token punctuation">,</span> devpth<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">&#39;xfs_growfs&#39;</span><span class="token punctuation">,</span> devpth<span class="token punctuation">)</span>\n\n\n<span class="token keyword">def</span> <span class="token function">_resize_ufs</span><span class="token punctuation">(</span>mount_point<span class="token punctuation">,</span> devpth<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">&#39;growfs&#39;</span><span class="token punctuation">,</span> devpth<span class="token punctuation">)</span>\n\n\n<span class="token comment"># Do not use a dictionary as these commands should be able to be used</span>\n<span class="token comment"># for multiple filesystem types if possible, e.g. one command for</span>\n<span class="token comment"># ext2, ext3 and ext4.</span>\nRESIZE_FS_PREFIXES_CMDS <span class="token operator">=</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">(</span><span class="token string">&#39;btrfs&#39;</span><span class="token punctuation">,</span> _resize_btrfs<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">(</span><span class="token string">&#39;ext&#39;</span><span class="token punctuation">,</span> _resize_ext<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">(</span><span class="token string">&#39;xfs&#39;</span><span class="token punctuation">,</span> _resize_xfs<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">(</span><span class="token string">&#39;ufs&#39;</span><span class="token punctuation">,</span> _resize_ufs<span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">]</span>\n</code></pre></div><h2 id="数据源实现" tabindex="-1"><a class="header-anchor" href="#数据源实现" aria-hidden="true">#</a> 数据源实现</h2><p><code>sources</code>下面是每个数据源的具体实现，openstack, aliyun这些都继承<code>__init__.py</code>中的元类<code>DataSource</code>. 这个metaclass实现了一些通用的操作。</p><p>openstack中通过访问 <code>http://169.254.169.254</code>获取信息<br> aliyun通过<code>http://100.100.100.200</code>获取<br> configdirve 查找<code>/dev/sr0</code>,<code>/dev/sr1</code>,<code>/dev/cd0</code>,<code>/dev/cd1</code>等设备，有则mount 后访问文件</p><h2 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件" aria-hidden="true">#</a> 配置文件</h2><p>cloud-init采用yaml格式的文件。yaml格式的具体说明参见 http://www.ruanyifeng.com/blog/2016/07/yaml.html<br> 特别注意：yaml不支持tab键，支持多个空格，但相同层级的元素左侧对齐。 cloud-init对布尔有特殊处理。 如下， true, 1, on, yes 均认为是true</p><div class="language-python ext-py"><pre class="language-python"><code>TRUE_STRINGS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;true&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;on&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;yes&#39;</span><span class="token punctuation">)</span>\nFALSE_STRINGS <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;off&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;no&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">)</span>\n</code></pre></div>',76),s={render:function(n,a){return t}}}}]);