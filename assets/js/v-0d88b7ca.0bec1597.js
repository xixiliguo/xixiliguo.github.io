(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[250],{3419:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>t});const t={key:"v-0d88b7ca",path:"/kernel/kernel-syscall-sched.html",title:"系统调用与进程调度",lang:"en-US",frontmatter:{title:"系统调用与进程调度",date:"2021-09-20T13:45:56.000Z",draft:!1},excerpt:"",headers:[{level:2,title:"64位下系统调用约定",slug:"_64位下系统调用约定",children:[]},{level:2,title:"task_struct部分字段的含义",slug:"task-struct部分字段的含义",children:[]},{level:2,title:"进程管理",slug:"进程管理",children:[]},{level:2,title:"调度细节",slug:"调度细节",children:[]}],filePathRelative:"kernel/kernel-syscall-sched.md",git:{updatedTime:1657468158e3,contributors:[]}}},2545:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>p});const t=(0,a(6252).uE)('<p>记录一些关于内核系统调用和进程调度相关的知识点, 以5.14内核为例</p><h2 id="_64位下系统调用约定" tabindex="-1"><a class="header-anchor" href="#_64位下系统调用约定" aria-hidden="true">#</a> 64位下系统调用约定</h2><p>c语言的函数调用过程中:<br> RDI, RSI, RDX, RCX, R8, R9 分别代表第一个,二个,三个... 参数, RAX代表返回值<br> RBX, RSP, RBP, and R12–R15 是调用者保存寄存器, 意思是调用者先保存原先值,在子函数返回时需要恢复,以确保该寄存器的值没变</p><p>Linux系统调用时稍微有一点不同, 第三个参数不是放到RCX, 而是R10. RCX用于保存切换时用户态时的RIP</p><p>下面是golang在linux amd64的系统调用汇编</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token comment">// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)</span>\nTEXT ·<span class="token function">Syscall6</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token operator">-</span><span class="token number">80</span>\n\tCALL\truntime·<span class="token function">entersyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>\n\tMOVQ\ta1<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> DI\n\tMOVQ\ta2<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> SI\n\tMOVQ\ta3<span class="token operator">+</span><span class="token function">24</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> DX\n\tMOVQ\ta4<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> R10  <span class="token comment">// 存放第三个参数</span>\n\tMOVQ\ta5<span class="token operator">+</span><span class="token function">40</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> R8\n\tMOVQ\ta6<span class="token operator">+</span><span class="token function">48</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> R9\n\tMOVQ\ttrap<span class="token operator">+</span><span class="token function">0</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX\t<span class="token comment">// syscall entry</span>\n\tSYSCALL\n\tCMPQ\tAX<span class="token punctuation">,</span> $<span class="token number">0xfffffffffffff001</span>    <span class="token comment">// 判断AX 是否小于 MAX_ERRNO:-4095 , 是则成功 </span>\n\tJLS\tok6\n\tMOVQ\t$<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>\n\tMOVQ\t$<span class="token number">0</span><span class="token punctuation">,</span> r2<span class="token operator">+</span><span class="token function">64</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>\n\tNEGQ\tAX\n\tMOVQ\tAX<span class="token punctuation">,</span> err<span class="token operator">+</span><span class="token function">72</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>             <span class="token comment">// 错误时, 则负值变正值, 返回具体的错误码</span>\n\tCALL\truntime·<span class="token function">exitsyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>\n\tRET\nok6<span class="token punctuation">:</span>\n\tMOVQ\tAX<span class="token punctuation">,</span> r1<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>\n\tMOVQ\tDX<span class="token punctuation">,</span> r2<span class="token operator">+</span><span class="token function">64</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>\n\tMOVQ\t$<span class="token number">0</span><span class="token punctuation">,</span> err<span class="token operator">+</span><span class="token function">72</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>\n\tCALL\truntime·<span class="token function">exitsyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>\n\tRET\n</code></pre></div><p>系统调用返回前, 会执行<code>callq</code>, 将有符号的4字节扩展为8字节. 比如0x80000000 变为 ffffffff80000000, 0x40000000仍是40000000<br> https://stackoverflow.com/questions/6555094/what-does-cltq-do-in-assembly<br> 所有系统调用的返回错误值范围为[-4095, -1], 所以可以无符号判断 RAX 小于 0xfffffffffffff001, 则为正常返回</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token comment">/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ERRNO</span>\t<span class="token expression"><span class="token number">4095</span></span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ASSEMBLY__</span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">IS_ERR_VALUE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span>MAX_ERRNO<span class="token punctuation">)</span></span></span>\n</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code> <span class="token operator">*</span> <span class="token operator">&lt;</span>__x64_sys_recv<span class="token operator">&gt;</span><span class="token operator">:</span>\t\t<span class="token operator">&lt;</span><span class="token operator">--</span> syscall with <span class="token number">4</span> parameters\n <span class="token operator">*</span>\tcallq\t<span class="token operator">&lt;</span>__fentry__<span class="token operator">&gt;</span>\n <span class="token operator">*</span>\n <span class="token operator">*</span>\tmov\t<span class="token number">0x70</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rdi\t<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>di\n <span class="token operator">*</span>\tmov\t<span class="token number">0x68</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rsi\t<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>si\n <span class="token operator">*</span>\tmov\t<span class="token number">0x60</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rdx\t<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>dx\n <span class="token operator">*</span>\tmov\t<span class="token number">0x38</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rcx\t<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>r10\n <span class="token operator">*</span>\n <span class="token operator">*</span>\txor\t<span class="token operator">%</span>r9d<span class="token punctuation">,</span><span class="token operator">%</span>r9d\t<span class="token operator">&lt;</span><span class="token operator">--</span> clear <span class="token operator">%</span>r9\n <span class="token operator">*</span>\txor\t<span class="token operator">%</span>r8d<span class="token punctuation">,</span><span class="token operator">%</span>r8d\t<span class="token operator">&lt;</span><span class="token operator">--</span> clear <span class="token operator">%</span>r8\n <span class="token operator">*</span>\n <span class="token operator">*</span>\tcallq\t__sys_recvfrom\t<span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token keyword">do</span> the actual work in <span class="token function">__sys_recvfrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n <span class="token operator">*</span>\t\t\t\t    which takes <span class="token number">6</span> arguments\n <span class="token operator">*</span>\n <span class="token operator">*</span>\tcltq\t\t\t<span class="token operator">&lt;</span><span class="token operator">--</span> extend <span class="token keyword">return</span> value to <span class="token number">64</span><span class="token operator">-</span>bit\n <span class="token operator">*</span>\tretq\t\t\t<span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token keyword">return</span>\n <span class="token operator">*</span>\n</code></pre></div><p>64位下不是通过INT 0x80, 而是通过syscall指令触发系统调用, 对应的函数为<code>entry_SYSCALL_64</code>, 在这个函数里, 用户态的很多原始信息,比如rip,rsp都保存在<code>struct pt_regs</code>里, 然后 entry_SYSCALL_64 --&gt; do_syscall_64<br> 通过给<code>MSR_LSTAR</code>寄存器写入entry_SYSCALL_64地址, 那么执行syscall指令时就是切换到汇编entry_SYSCALL_64</p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token function">wrmsr</span><span class="token punctuation">(</span>MSR_STAR<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>__USER32_CS <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> __KERNEL_CS<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>将用户态时的rsp保存到per cpu变量cpu_tss_rw里面, 切换cpu为内核模式, 然后依次将寄存器里的值push, 填充pt_regs结构体. 保存所有用户态相关的信息<br> 从代码上看, 执行do_syscall_64前中断是关闭的, 在<code>syscall_enter_from_user_mode</code>里打开, 从<code>do_syscall_64</code>返回时又关闭了, 等执行了sysret后应该又打开了</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">SYM_CODE_START</span><span class="token punctuation">(</span>entry_SYSCALL_64<span class="token punctuation">)</span>\n\tUNWIND_HINT_EMPTY\n\n\tswapgs\n\t<span class="token comment">/* tss.sp2 is scratch space. */</span>\n\tmovq\t<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>cpu_tss_rw <span class="token operator">+</span> TSS_sp2<span class="token punctuation">)</span>\n\tSWITCH_TO_KERNEL_CR3 scratch_reg<span class="token operator">=</span><span class="token operator">%</span>rsp\n\tmovq\t<span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>cpu_current_top_of_stack<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp\n\n<span class="token function">SYM_INNER_LABEL</span><span class="token punctuation">(</span>entry_SYSCALL_64_safe_stack<span class="token punctuation">,</span> SYM_L_GLOBAL<span class="token punctuation">)</span>\n\n\t<span class="token comment">/* Construct struct pt_regs on stack */</span>\n\tpushq\t$__USER_DS\t\t\t\t<span class="token comment">/* pt_regs-&gt;ss */</span>\n\tpushq\t<span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>cpu_tss_rw <span class="token operator">+</span> TSS_sp2<span class="token punctuation">)</span>\t<span class="token comment">/* pt_regs-&gt;sp */</span>\n\tpushq\t<span class="token operator">%</span>r11\t\t\t\t\t<span class="token comment">/* pt_regs-&gt;flags */</span>\n\tpushq\t$__USER_CS\t\t\t\t<span class="token comment">/* pt_regs-&gt;cs */</span>\n\tpushq\t<span class="token operator">%</span>rcx\t\t\t\t\t<span class="token comment">/* pt_regs-&gt;ip */</span>\n<span class="token function">SYM_INNER_LABEL</span><span class="token punctuation">(</span>entry_SYSCALL_64_after_hwframe<span class="token punctuation">,</span> SYM_L_GLOBAL<span class="token punctuation">)</span>\n\tpushq\t<span class="token operator">%</span>rax\t\t\t\t\t<span class="token comment">/* pt_regs-&gt;orig_ax */</span>\n\n\tPUSH_AND_CLEAR_REGS rax<span class="token operator">=</span>$<span class="token operator">-</span>ENOSYS\n\n\t<span class="token comment">/* IRQs are off. */</span>\n\tmovq\t<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rdi\n\t<span class="token comment">/* Sign extend the lower 32bit as syscall numbers are treated as int */</span>\n\tmovslq\t<span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span>rsi\n\tcall\tdo_syscall_64\t\t<span class="token comment">/* returns with IRQs disabled */</span>\n</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code>__visible noinstr <span class="token keyword">void</span> <span class="token function">do_syscall_64</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token function">add_random_kstack_offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\tnr <span class="token operator">=</span> <span class="token function">syscall_enter_from_user_mode</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token comment">/* syscall_enter_from_user_mode里面会检查一些权限, 比如是否满足SECCOMP. 对系统调用的审计也在这里 \n\t * 如果返回-1, 则不会执行下面的函数, 最终给用户态程序返回 -ENOSYS\n\t*/</span>\n\n\t<span class="token function">instrumentation_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">do_syscall_x64</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> nr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">do_syscall_x32</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> nr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nr <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token comment">/* Invalid system call, but still a system call. */</span>\n\t\tregs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> <span class="token function">__x64_sys_ni_syscall</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\n\t<span class="token function">instrumentation_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">syscall_exit_to_user_mode</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>所有的系统调用的具体实现函数, 汇总到<code>sys_call_table</code>,同时<code>arch/x86/entry/syscalls/syscall_64.tbl</code> 里也可以直接查询系统调用号与具体实现函数名的对应关系</p><div class="language-c ext-c"><pre class="language-c"><code>crash<span class="token operator">&gt;</span> whatis sys_call_table\n<span class="token keyword">const</span> <span class="token class-name">sys_call_ptr_t</span> sys_call_table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ncrash<span class="token operator">&gt;</span> p sys_call_table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n$<span class="token number">9</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">sys_call_ptr_t</span><span class="token punctuation">)</span> <span class="token number">0xffffffffb9b19c30</span>\ncrash<span class="token operator">&gt;</span> sym <span class="token number">0xffffffffb9b19c30</span>\n<span class="token function">ffffffffb9b19c30</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> __x64_sys_read <span class="token operator">/</span>usr<span class="token operator">/</span>src<span class="token operator">/</span>debug<span class="token operator">/</span>kernel<span class="token operator">-</span><span class="token number">4.18</span><span class="token number">.0</span><span class="token operator">-</span><span class="token number">305.3</span><span class="token number">.1</span><span class="token punctuation">.</span>el8_4<span class="token operator">/</span>linux<span class="token operator">-</span><span class="token number">4.18</span><span class="token number">.0</span><span class="token operator">-</span><span class="token number">305.3</span><span class="token number">.1</span><span class="token punctuation">.</span>el8<span class="token punctuation">.</span>x86_64<span class="token operator">/</span>fs<span class="token operator">/</span>read_write<span class="token punctuation">.</span>c<span class="token operator">:</span> <span class="token number">586</span>\ncrash<span class="token operator">&gt;</span>\n</code></pre></div><p><code>syscall_exit_to_user_mode -&gt; __syscall_exit_to_user_mode_work --&gt; exit_to_user_mode_prepare --&gt; exit_to_user_mode_loop</code>, 在exit_to_user_mode_loop里有一些重要的事情要做.<br> 如果该进程被标记为需要调度,即需要让出cpu,让其他进程执行<br> 该进程收到信号需要处理, 也是在退出syscall返回用户态空间前执行的</p><p><code>mov 0x38(%rdi),%ecx</code> 可以看到确实是将陷入内核态前的R10(代表第三个参数)赋值给RCX, 满足后续C语言的调用规约</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; dis -l __x64_sys_recv\n/usr/src/debug/kernel-5.14.0-22.el9/linux-5.14.0-22.el9.x86_64/net/socket.c: 2111\n0xffffffffa21f4400 &lt;__x64_sys_recv&gt;:    nopl   0x0(%rax,%rax,1) [FTRACE NOP]\n/usr/src/debug/kernel-5.14.0-22.el9/linux-5.14.0-22.el9.x86_64/net/socket.c: 2114\n0xffffffffa21f4405 &lt;__x64_sys_recv+5&gt;:  mov    0x60(%rdi),%rdx\n0xffffffffa21f4409 &lt;__x64_sys_recv+9&gt;:  mov    0x68(%rdi),%rsi\n0xffffffffa21f440d &lt;__x64_sys_recv+13&gt;: xor    %r9d,%r9d\n0xffffffffa21f4410 &lt;__x64_sys_recv+16&gt;: xor    %r8d,%r8d\n0xffffffffa21f4413 &lt;__x64_sys_recv+19&gt;: mov    0x38(%rdi),%ecx\n0xffffffffa21f4416 &lt;__x64_sys_recv+22&gt;: mov    0x70(%rdi),%edi\n0xffffffffa21f4419 &lt;__x64_sys_recv+25&gt;: call   0xffffffffa21f4210 &lt;__sys_recvfrom&gt;\n/usr/src/debug/kernel-5.14.0-22.el9/linux-5.14.0-22.el9.x86_64/net/socket.c: 2111\n0xffffffffa21f441e &lt;__x64_sys_recv+30&gt;: cltq\n0xffffffffa21f4420 &lt;__x64_sys_recv+32&gt;: ret\ncrash&gt; struct pt_regs -xo | grep 0x38\n  [0x38] unsigned long r10;\ncrash&gt;\n</code></pre></div><p><code>sysretq</code>指令从RCS载入值到RIP, 返回用户态</p><p>从代码中搜索系统调用具体函数的技巧: 以open为例, 它有三个参数, 则通过<code>define3(open</code> 就能很快找到对应的实现</p><p>参考:<br> http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/<br> https://en.wikipedia.org/wiki/X86_calling_conventions<br> https://cloud.tencent.com/developer/article/1492374</p><h2 id="task-struct部分字段的含义" tabindex="-1"><a class="header-anchor" href="#task-struct部分字段的含义" aria-hidden="true">#</a> task_struct部分字段的含义</h2><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>\nu64        utime<span class="token punctuation">;</span><span class="token comment">//用户态消耗的CPU时间</span>\nu64        stime<span class="token punctuation">;</span><span class="token comment">//内核态消耗的CPU时间</span>\n<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      nvcsw<span class="token punctuation">;</span><span class="token comment">//自愿(voluntary)上下文切换计数</span>\n<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      nivcsw<span class="token punctuation">;</span><span class="token comment">//非自愿(involuntary)上下文切换计数</span>\nu64        start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，不包含睡眠时间</span>\nu64        real_start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，包含睡眠时间</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>utime, stime单位为ns, 两次时钟中断触发的时间间隔为<code>1/HZ</code>. 内核里面HZ一般是1000,(centos是1000, ubuntu是250), 在函数<code>account_process_tick</code>里每次更新utime,stime都是增加<code>TICK_NSEC</code> - steal-time`, TICK_NSEC为1000000,</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grep CONFIG_HZ= /boot/config-5.14.0-22.el9.x86_64</span>\n<span class="token assign-left variable">CONFIG_HZ</span><span class="token operator">=</span><span class="token number">1000</span>\n</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code>\n<span class="token comment">/* TICK_NSEC is the time between ticks in nsec assuming SHIFTED_HZ */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TICK_NSEC</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>NSEC_PER_SEC<span class="token operator">+</span>HZ<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">/</span>HZ<span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Account a tick to a process and cpustat\n * @p: the process that the CPU time gets accounted to\n * @user_tick: is the tick from userspace\n * @rq: the pointer to rq\n *\n * Tick demultiplexing follows the order\n * - pending hardirq update\n * - pending softirq update\n * - user_time\n * - idle_time\n * - system time\n *   - check for guest_time\n *   - else account as system_time\n *\n * Check for hardirq is done both for system and user time as there is\n * no timer going off while we are on hardirq and hence we may never get an\n * opportunity to update it solely in system time.\n * p-&gt;stime and friends are only updated on system time and not on irq\n * softirq as those do not count in task exec_runtime any more.\n */</span>\n<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">irqtime_account_process_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> user_tick<span class="token punctuation">,</span>\n\t\t\t\t\t <span class="token keyword">int</span> ticks<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\tu64 other<span class="token punctuation">,</span> cputime <span class="token operator">=</span> TICK_NSEC <span class="token operator">*</span> ticks<span class="token punctuation">;</span>\n\n\t<span class="token comment">/*\n\t * When returning from idle, many ticks can get accounted at\n\t * once, including some ticks of steal, irq, and softirq time.\n\t * Subtract those ticks from the amount of time accounted to\n\t * idle, or potentially user or system time. Due to rounding,\n\t * other time can exceed ticks occasionally.\n\t */</span>\n\tother <span class="token operator">=</span> <span class="token function">account_other_time</span><span class="token punctuation">(</span>ULONG_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">&gt;=</span> cputime<span class="token punctuation">)</span>\n\t\t<span class="token keyword">return</span><span class="token punctuation">;</span>\n\n\tcputime <span class="token operator">-=</span> other<span class="token punctuation">;</span>\n\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">this_cpu_ksoftirqd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token comment">/*\n\t\t * ksoftirqd time do not get accounted in cpu_softirq_time.\n\t\t * So, we have to handle it separately here.\n\t\t * Also, p-&gt;stime needs to be updated for ksoftirqd.\n\t\t */</span>\n\t\t<span class="token function">account_system_index_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">,</span> CPUTIME_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>user_tick<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token function">account_user_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token function">this_rq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>idle<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token function">account_idle_time</span><span class="token punctuation">(</span>cputime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> PF_VCPU<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* System time or guest time */</span>\n\t\t<span class="token function">account_guest_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n\t\t<span class="token function">account_system_index_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">,</span> CPUTIME_SYSTEM<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>大致的调用关系</p><div class="language-text ext-text"><pre class="language-text"><code>     \tirqtime_account_process_tick+1\n        update_process_times+81\n        tick_sched_handle+34\n        tick_sched_timer+97\n        __hrtimer_run_queues+298\n        hrtimer_interrupt+272\n        __sysvec_apic_timer_interrupt+92\n        sysvec_apic_timer_interrupt+55\n        asm_sysvec_apic_timer_interrupt+18\n</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code>update_process_times\n\tirqtime_account_process_tick     <span class="token comment">/* 更新cpu信息 */</span>\n\tscheduler_tick                   <span class="token comment">/* 更新调度相关的信息, 比如 vruntime */</span>\n</code></pre></div><p>start_time, real_start_time单位是ns, 指自系统启动以来到进程创建时流逝的时间, 在<code>copy_process</code>里赋值</p><div class="language-text ext-text"><pre class="language-text"><code>\tp-&gt;start_time = ktime_get_ns();\n\tp-&gt;real_start_time = ktime_get_boot_ns();\n</code></pre></div><p>如下显示systemd进程时系统启动17ms后创建, 截止dump生成,以运行6小时多.</p><div class="language-bash ext-sh"><pre class="language-bash"><code>crash<span class="token operator">&gt;</span> <span class="token function">ps</span> -t <span class="token number">1</span>\nPID: <span class="token number">1</span>      TASK: ffff8fb0c6dc2f80  CPU: <span class="token number">0</span>   COMMAND: <span class="token string">&quot;systemd&quot;</span>\n    RUN TIME: 06:34:57\n  START TIME: <span class="token number">17000000</span>\n       UTIME: <span class="token number">1072507605</span>\n       STIME: <span class="token number">1248244355</span>\n\ncrash<span class="token operator">&gt;</span>\n</code></pre></div><p>我们在<code>/proc/[pid]/stat</code>里看到的utime 和 stime单位是clock ticks, 内核里HZ每个版本可能不一样, 但为了保持用户态的一致性,暴露给用户态的USER_HZ却一直都是100. 通过<code>nsec_to_clock_t</code> 将task_struct-&gt;utime,stime转化为<code>ticks</code>. 在centos8 x86_64环境为<code>x/( NSEC_PER_SEC / USER_HZ)</code></p><div class="language-c ext-c"><pre class="language-c"><code>u64 <span class="token class-name">nsec_to_clock_t</span><span class="token punctuation">(</span>u64 x<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>NSEC_PER_SEC <span class="token operator">%</span> USER_HZ<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span></span></span>\n\t<span class="token keyword">return</span> <span class="token function">div_u64</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> NSEC_PER_SEC <span class="token operator">/</span> USER_HZ<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token punctuation">(</span>USER_HZ <span class="token operator">%</span> <span class="token number">512</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span></span></span>\n\t<span class="token keyword">return</span> <span class="token function">div_u64</span><span class="token punctuation">(</span>x <span class="token operator">*</span> USER_HZ <span class="token operator">/</span> <span class="token number">512</span><span class="token punctuation">,</span> NSEC_PER_SEC <span class="token operator">/</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>\n\t<span class="token comment">/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ &lt;= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */</span>\n\t<span class="token keyword">return</span> <span class="token function">div_u64</span><span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9ull</span> <span class="token operator">*</span> NSEC_PER_SEC <span class="token operator">+</span> <span class="token punctuation">(</span>USER_HZ <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> USER_HZ<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>/proc/[pid]/stat</code>的具体实现在<code>fs/proc/array.c</code>里的<code>do_task_stat</code></p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token function">seq_put_decimal_ull</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span> <span class="token class-name">nsec_to_clock_t</span><span class="token punctuation">(</span>utime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">seq_put_decimal_ull</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span> <span class="token class-name">nsec_to_clock_t</span><span class="token punctuation">(</span>stime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p><code>top</code>里显示cpu的hi和si在<code>irqtime_account_irq</code>计算, 该函数在irq_enter和irq_exit时运行. ksoftirq的处理时间不仅算在自己进程的stime上, 还会算到cpu的si上面</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_softirq_enter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token function">vtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> SOFTIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> SOFTIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/*更新starttime, 但第二个参数不让计算差值*/</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_softirq_exit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token function">vtime_account_softirq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">/*更新starttime, 并将差值(now-starttime)统计进去*/</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_hardirq_enter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token function">vtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> HARDIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> HARDIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/*更新starttime, 但第二个参数不让计算差值*/</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_hardirq_exit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token function">vtime_account_hardirq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/*更新starttime, 并将差值(now-starttime)统计进去*/</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>通过task获取pt_regs的函数如下, 这里记录了进程进入内核态时, 保存的一些用户态信息.</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KASAN</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KASAN_STACK_ORDER</span> <span class="token expression"><span class="token number">1</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KASAN_STACK_ORDER</span> <span class="token expression"><span class="token number">0</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE_ORDER</span>\t<span class="token expression"><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> KASAN_STACK_ORDER<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE</span>  <span class="token expression"><span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span>\n\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_pt_regs</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>\n<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>\t\t\t\t\t\t\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression">__ptr <span class="token operator">+=</span> THREAD_SIZE <span class="token operator">-</span> TOP_OF_KERNEL_STACK_PADDING<span class="token punctuation">;</span>\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span><span class="token punctuation">)</span>__ptr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>\t\t\t\t\t</span><span class="token punctuation">\\</span>\n<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_VM86</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">16</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">8</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">0</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>\n\n\n</code></pre></div><p>pid的类型为int,但pidmax默认值在kernel/pid.c里的<code>pid_idr_init</code>设置, 新分配的pid是上一次分配的pid加1, 直到pid_max, 然后循环使用已闲置的最小pid.</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">void</span> __init <span class="token function">pid_idr_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token comment">/* Verify no one has done anything silly: */</span>\n\t<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>PID_MAX_LIMIT <span class="token operator">&gt;=</span> PIDNS_ADDING<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t<span class="token comment">/* bump default and minimum pid_max based on number of cpus */</span>\n\tpid_max <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>pid_max_max<span class="token punctuation">,</span> <span class="token class-name">max_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> pid_max<span class="token punctuation">,</span>\n\t\t\t\tPIDS_PER_CPU_DEFAULT <span class="token operator">*</span> <span class="token function">num_possible_cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\tpid_max_min <span class="token operator">=</span> <span class="token class-name">max_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> pid_max_min<span class="token punctuation">,</span>\n\t\t\t\tPIDS_PER_CPU_MIN <span class="token operator">*</span> <span class="token function">num_possible_cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">&quot;pid_max: default: %u minimum: %u\\n&quot;</span><span class="token punctuation">,</span> pid_max<span class="token punctuation">,</span> pid_max_min<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t<span class="token function">idr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>init_pid_ns<span class="token punctuation">.</span>idr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\tinit_pid_ns<span class="token punctuation">.</span>pid_cachep <span class="token operator">=</span> <span class="token function">KMEM_CACHE</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span>\n\t\t\tSLAB_HWCACHE_ALIGN <span class="token operator">|</span> SLAB_PANIC <span class="token operator">|</span> SLAB_ACCOUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>如果要通过<code>sysctl -w kernel.pid_max=xxx</code>调节, 64位下最大值为4194304. 一般CONFIG_BASE_SMALL为N.</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token comment">/*\n * A maximum of 4 million PIDs should be enough for a while.\n * [NOTE: PID/TIDs are limited to 2^29 ~= 500+ million, see futex.h.]\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PID_MAX_LIMIT</span> <span class="token expression"><span class="token punctuation">(</span>CONFIG_BASE_SMALL <span class="token operator">?</span> PAGE_SIZE <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">:</span> </span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">:</span> PID_MAX_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>\n</code></pre></div><p>在<code>copy_process</code>里先判断是否超过ulimit里面的限制, 但root用户的进程不受这个限制</p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_ucounts_overlimit</span><span class="token punctuation">(</span><span class="token function">task_ucounts</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> UCOUNT_RLIMIT_NPROC<span class="token punctuation">,</span> <span class="token function">rlimit</span><span class="token punctuation">(</span>RLIMIT_NPROC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>real_cred<span class="token operator">-&gt;</span>user <span class="token operator">!=</span> INIT_USER <span class="token operator">&amp;&amp;</span>\n\t\t    <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_RESOURCE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t\t\t<span class="token keyword">goto</span> bad_fork_free<span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n</code></pre></div><p>如果当前的线程数(其实就是task_struct的数量, 在linux进程和线程其实是都是task_struct), 超过/proc/sys/kernel/threads-max, 也会报错</p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token comment">/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn&#39;t hurt, the check is only there\n\t * to stop root fork bombs.\n\t */</span>\n\tretval <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">data_race</span><span class="token punctuation">(</span>nr_threads <span class="token operator">&gt;=</span> max_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t\t<span class="token keyword">goto</span> bad_fork_cleanup_count<span class="token punctuation">;</span>\n</code></pre></div><p>紧接着如果因超过pid_max, 且没闲置的pid, 则会导致创建进程失败.</p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> <span class="token operator">&amp;</span>init_struct_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\tpid <span class="token operator">=</span> <span class="token function">alloc_pid</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>pid_ns_for_children<span class="token punctuation">,</span> args<span class="token operator">-&gt;</span>set_tid<span class="token punctuation">,</span>\n\t\t\t\targs<span class="token operator">-&gt;</span>set_tid_size<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t\tretval <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t\t<span class="token keyword">goto</span> bad_fork_cleanup_thread<span class="token punctuation">;</span>\n\t\t<span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n</code></pre></div><p>最后还会检查cgroup里的的pid_max限制</p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token comment">/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process&#39;s css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */</span>\n\tretval <span class="token operator">=</span> <span class="token function">cgroup_can_fork</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>\n\t\t<span class="token keyword">goto</span> bad_fork_put_pidfd<span class="token punctuation">;</span>\n\n</code></pre></div><p>日志里面有如下报错,就是因为这个原因<br> cgroup: fork rejected by pids controller in /user.slice/user-0.slice/session-7.scope</p><p>我们再来看经常遇到的超过文件句柄数相关的一些知识<br> 通过<code>ulimit -n</code>设置进程最大的打开文件数, 最大值为<code>1048576</code>, 它是受限于<code>sysctl fs.nr_open</code></p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_nr_open __read_mostly <span class="token operator">=</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>   <span class="token comment">//默认值</span>\n<span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_nr_open_min <span class="token operator">=</span> BITS_PER_LONG<span class="token punctuation">;</span>\n<span class="token comment">/* our min() is unusable in constant expressions ;-/ */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__const_min</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>\n<span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_nr_open_max <span class="token operator">=</span>\n\t<span class="token function">__const_min</span><span class="token punctuation">(</span>INT_MAX<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">-</span>BITS_PER_LONG<span class="token punctuation">;</span>  <span class="token comment">//最大值</span>\n</code></pre></div><p>有两个跟文件句柄数的报错, <code>ENFILE</code>表示超过了OS整的系统限制, <code>EMFILE</code>表示超过了自身的<code>/proc/[pid]/limits</code>里面<code>Max open files</code>的限制</p><div class="language-text ext-text"><pre class="language-text"><code>/usr/include/asm-generic/errno-base.h:#define   ENFILE          23      /* File table overflow */\n/usr/include/asm-generic/errno-base.h:#define   EMFILE          24      /* Too many open files */\n</code></pre></div><p>OS系统级所有打开的文件句柄最大数, 普通用户受限, 但root的进程不受限</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost abc<span class="token punctuation">]</span><span class="token comment"># sysctl fs.file-nr</span>\nfs.file-nr <span class="token operator">=</span> <span class="token number">1984</span>       <span class="token number">0</span>       <span class="token number">789985</span>\n<span class="token punctuation">[</span>root@localhost abc<span class="token punctuation">]</span><span class="token comment"># sysctl fs.file-max</span>\nfs.file-max <span class="token operator">=</span> <span class="token number">789985</span>\n<span class="token punctuation">[</span>root@localhost abc<span class="token punctuation">]</span><span class="token comment">#</span>\n</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token function">alloc_empty_file</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>cred<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">static</span> <span class="token keyword">long</span> old_max<span class="token punctuation">;</span>\n\t<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>\n\n\t<span class="token comment">/*\n\t * Privileged users can go above max_files\n\t */</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_nr_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> files_stat<span class="token punctuation">.</span>max_files <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token comment">/*\n\t\t * percpu_counters are inaccurate.  Do an expensive check before\n\t\t * we go and fail.\n\t\t */</span>\n\t\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">percpu_counter_sum_positive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nr_files<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> files_stat<span class="token punctuation">.</span>max_files<span class="token punctuation">)</span>\n\t\t\t<span class="token keyword">goto</span> over<span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\n\tf <span class="token operator">=</span> <span class="token function">__alloc_file</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> cred<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t\t<span class="token function">percpu_counter_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nr_files<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t<span class="token keyword">return</span> f<span class="token punctuation">;</span>\n\nover<span class="token operator">:</span>\n\t<span class="token comment">/* Ran out of filps - report that */</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_nr_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> old_max<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">&quot;VFS: file-max limit %lu reached\\n&quot;</span><span class="token punctuation">,</span> <span class="token function">get_max_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\told_max <span class="token operator">=</span> <span class="token function">get_nr_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>ENFILE<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>task_struct-&gt;stack 指向进程的内核栈, 在 dup_task_struct --&gt; alloc_thread_stack_node 里面分配, 通常是通过vmalloc分配, 而不是slab系统</p><div class="language-c ext-c"><pre class="language-c"><code>\t<span class="token comment">/*\n\t * Allocated stacks are cached and later reused by new threads,\n\t * so memcg accounting is performed manually on assigning/releasing\n\t * stacks to tasks. Drop __GFP_ACCOUNT.\n\t */</span>\n\tstack <span class="token operator">=</span> <span class="token function">__vmalloc_node_range</span><span class="token punctuation">(</span>THREAD_SIZE<span class="token punctuation">,</span> THREAD_ALIGN<span class="token punctuation">,</span>\n\t\t\t\t     VMALLOC_START<span class="token punctuation">,</span> VMALLOC_END<span class="token punctuation">,</span>\n\t\t\t\t     THREADINFO_GFP <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ACCOUNT<span class="token punctuation">,</span>\n\t\t\t\t     PAGE_KERNEL<span class="token punctuation">,</span>\n\t\t\t\t     <span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n\t<span class="token comment">/*\n\t * We can&#39;t call find_vm_area() in interrupt context, and\n\t * free_thread_stack() can be called in interrupt context,\n\t * so cache the vm_struct.\n\t */</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\ttsk<span class="token operator">-&gt;</span>stack_vm_area <span class="token operator">=</span> <span class="token function">find_vm_area</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\ttsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> stack<span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; task | grep stack\n  stack = 0xffff97c5825e0000,\n  stack_canary = 2863369865746246656,\n  curr_ret_stack = -1,\n  ret_stack = 0x0,\n  stack_vm_area = 0xffff8c900af5b040,\n  stack_refcount = {\ncrash&gt; grep 0xffff97c5825e0000 /proc/vmallocinfo\n0xffff97c5825e0000-0xffff97c5825e5000   20480 dup_task_struct+0x49/0x300 pages=4 vmalloc N0=4\ncrash&gt;\n</code></pre></div><h2 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h2><p><code>current</code>永远指向当前cpu上运行的进程的task_struct, 实现方式如下</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">current</span> <span class="token expression"><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>\n</code></pre></div><p><code>init_task</code>代表了pid为0的进程, 即swapper/0, 通过它和<code>task_struct.tasks</code>可以找到所有进程</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; list task_struct.tasks -s task_struct.comm -h init_task | head -19\nffffffffb481a940\n  comm = &quot;swapper/0\\000\\000\\000\\000\\000\\000&quot;,\nffff9dd300218000\n  comm = &quot;systemd\\000\\060\\000\\000\\000\\000\\000\\000&quot;,\nffff9dd30021e300\n  comm = &quot;kthreadd\\000\\000\\000\\000\\000\\000\\000&quot;,\nffff9dd30021ca40\n  comm = &quot;rcu_gp\\000d\\000\\000\\000\\000\\000\\000\\000&quot;,\nffff9dd3002198c0\n  comm = &quot;rcu_par_gp\\000\\000\\000\\000\\000&quot;,\nffff9dd30023b180\n  comm = &quot;kworker/0:0H\\000\\000\\000&quot;,\nffff9dd30023ca40\n  comm = &quot;mm_percpu_wq\\000\\000\\000&quot;,\nffff9dd3002398c0\n  comm = &quot;rcu_tasks_kthre&quot;,\nffff9dd300266300\n  comm = &quot;rcu_tasks_rude_&quot;,\nffff9dd300264a40\n\ncrash&gt;\n</code></pre></div><p>普通进程的nice值是优先级. 用户态显示的范围为 [-20 ~ 19], 值越低,优先级越高.对应的task_struct的字段为static_prio, 取值为[100～139]</p><div class="language-c ext-c"><pre class="language-c"><code>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_NICE</span>\t<span class="token expression"><span class="token number">19</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MIN_NICE</span>\t<span class="token expression"><span class="token operator">-</span><span class="token number">20</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NICE_WIDTH</span>\t<span class="token expression"><span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> MIN_NICE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Priority of a process goes from 0..MAX_PRIO-1, valid RT\n * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH\n * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority\n * values are inverted: lower p-&gt;prio value means higher priority.\n *\n * The MAX_USER_RT_PRIO value allows the actual maximum\n * RT priority to be separate from the value exported to\n * user-space.  This allows kernel threads to set their\n * priority to a value higher than any user task. Note:\n * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.\n */</span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_RT_PRIO</span>\t<span class="token expression"><span class="token number">100</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_RT_PRIO</span>\t\t<span class="token expression">MAX_USER_RT_PRIO</span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PRIO</span>\t\t<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_PRIO</span>\t\t<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Convert user-nice values [ -20 ... 0 ... 19 ]\n * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],\n * and back.\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NICE_TO_PRIO</span><span class="token expression"><span class="token punctuation">(</span>nice<span class="token punctuation">)</span>\t<span class="token punctuation">(</span><span class="token punctuation">(</span>nice<span class="token punctuation">)</span> <span class="token operator">+</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRIO_TO_NICE</span><span class="token expression"><span class="token punctuation">(</span>prio<span class="token punctuation">)</span>\t<span class="token punctuation">(</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span> <span class="token operator">-</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * &#39;User priority&#39; is the nice value converted to something we\n * can work with better when scaling various scheduler parameters,\n * it&#39;s a [ 0 ... 39 ] range.\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>\t\t<span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span>MAX_RT_PRIO<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TASK_USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>\t<span class="token function">USER_PRIO</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_PRIO</span>\t\t<span class="token expression"><span class="token punctuation">(</span><span class="token function">USER_PRIO</span><span class="token punctuation">(</span>MAX_PRIO<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Convert nice value [19,-20] to rlimit style value [1,40].\n */</span>\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">nice_to_rlimit</span><span class="token punctuation">(</span><span class="token keyword">long</span> nice<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> nice <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n<span class="token comment">/**\n * task_nice - return the nice value of a given task.\n * @p: the task in question.\n *\n * Return: The nice value [ -20 ... 0 ... 19 ].\n */</span>\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">task_nice</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token function">PRIO_TO_NICE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n```普通进程的nice值是优先级<span class="token punctuation">.</span> 用户态显示的范围为 <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">20</span> <span class="token operator">~</span> <span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 值越低<span class="token punctuation">,</span>优先级越高<span class="token punctuation">.</span>对应的task_struct的字段为static_prio<span class="token punctuation">,</span> 取值为<span class="token punctuation">[</span><span class="token number">100</span>～<span class="token number">139</span><span class="token punctuation">]</span>\n\n``` c\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_NICE</span>\t<span class="token expression"><span class="token number">19</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MIN_NICE</span>\t<span class="token expression"><span class="token operator">-</span><span class="token number">20</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NICE_WIDTH</span>\t<span class="token expression"><span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> MIN_NICE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Priority of a process goes from 0..MAX_PRIO-1, valid RT\n * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH\n * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority\n * values are inverted: lower p-&gt;prio value means higher priority.\n *\n * The MAX_USER_RT_PRIO value allows the actual maximum\n * RT priority to be separate from the value exported to\n * user-space.  This allows kernel threads to set their\n * priority to a value higher than any user task. Note:\n * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.\n */</span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_RT_PRIO</span>\t<span class="token expression"><span class="token number">100</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_RT_PRIO</span>\t\t<span class="token expression">MAX_USER_RT_PRIO</span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PRIO</span>\t\t<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_PRIO</span>\t\t<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Convert user-nice values [ -20 ... 0 ... 19 ]\n * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],\n * and back.\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NICE_TO_PRIO</span><span class="token expression"><span class="token punctuation">(</span>nice<span class="token punctuation">)</span>\t<span class="token punctuation">(</span><span class="token punctuation">(</span>nice<span class="token punctuation">)</span> <span class="token operator">+</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRIO_TO_NICE</span><span class="token expression"><span class="token punctuation">(</span>prio<span class="token punctuation">)</span>\t<span class="token punctuation">(</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span> <span class="token operator">-</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * &#39;User priority&#39; is the nice value converted to something we\n * can work with better when scaling various scheduler parameters,\n * it&#39;s a [ 0 ... 39 ] range.\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>\t\t<span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span>MAX_RT_PRIO<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TASK_USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>\t<span class="token function">USER_PRIO</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_PRIO</span>\t\t<span class="token expression"><span class="token punctuation">(</span><span class="token function">USER_PRIO</span><span class="token punctuation">(</span>MAX_PRIO<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>\n\n<span class="token comment">/*\n * Convert nice value [19,-20] to rlimit style value [1,40].\n */</span>\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">nice_to_rlimit</span><span class="token punctuation">(</span><span class="token keyword">long</span> nice<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> nice <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n<span class="token comment">/**\n * task_nice - return the nice value of a given task.\n * @p: the task in question.\n *\n * Return: The nice value [ -20 ... 0 ... 19 ].\n */</span>\n<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">task_nice</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token function">PRIO_TO_NICE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="调度细节" tabindex="-1"><a class="header-anchor" href="#调度细节" aria-hidden="true">#</a> 调度细节</h2><p>linux支持的调度策略如下</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token comment">/*\n * The order of the sched class addresses are important, as they are\n * used to determine the order of the priority of each sched class in\n * relation to each other.\n */</span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_DATA</span>\t\t\t\t<span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token function">STRUCT_ALIGN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression">__begin_sched_classes <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">;</span>\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__idle_sched_class<span class="token punctuation">)</span>\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__fair_sched_class<span class="token punctuation">)</span>\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__rt_sched_class<span class="token punctuation">)</span>\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__dl_sched_class<span class="token punctuation">)</span>\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__stop_sched_class<span class="token punctuation">)</span>\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression">__end_sched_classes <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">;</span></span></span>\n\n</code></pre></div><p>struct rq.clock 的单位是ns, cfs里<code>update_curr</code>用于更新进程运行时的统计量</p><p>分两种情况:</p><ol><li>主动式调度 当写IO,或者等待其他资源时,主动让出cpu的, 代码中直接调用<code>__schedule</code></li><li>被动式调度 <ul><li>自身时间执行时间过长,占用cpu过多, 调度管理会通过时钟中断调用<code>scheduler_tick</code>更新进程相关的统计信息, 判断是否需要重新调度. 如果时,则将该进程标记为<code>_TIF_NEED_RESCHED</code><ul><li>curr-&gt;sched_class-&gt;task_tick(rq, curr, 0) 里调用 entity_tick()</li><li>entity_tick() 调用 update_curr 更新当前进程 vruntime, 调用 check_preempt_tick 检测是否需要被调度</li><li>check_preempt_tick 中判断已运行的是否是否大于ideal_runtime(估算的进程应该运行的时间), 当前进程的vruntime和队列里最小的vruntime, 如果超过阈值,说明有其他进程更需要运行.</li></ul></li><li>被刚刚唤醒的进程,如果优先级更高,也会标记为<code>_TIF_NEED_RESCHED</code><ul><li>try_to_wake_up -&gt; ttwu_queue -&gt; ttwu_do_activate -&gt; activate_task 加入到可运行队列</li><li>try_to_wake_up -&gt; ttwu_queue -&gt; ttwu_do_activate -&gt; ttwu_do_wakeup 检查是否需要被调度</li></ul></li><li>抢占时机, 什么时候让已标记为<code>_TIF_NEED_RESCHED</code>的运行<code>__schedule</code>调出去 <ul><li>用户态进程 <ul><li>系统调用调用返回时,在<code>exit_to_user_mode_loop</code>里</li><li>中断返回时, irqentry_exit --&gt; irqentry_exit_to_user_mode --&gt; exit_to_user_mode_prepare --&gt; exit_to_user_mode_loop</li></ul></li><li>内核态进程 如果没有配置<code>CONFIG_PREEMPT=y</code>, 那么内核态运行时无法抢占, 假设该功能打开则: <ul><li>中断返回时,irqentry_exit --&gt; irqentry_exit_cond_resched --&gt; preempt_schedule_irq</li><li>preempt_disable在某些路径关闭抢占后, 用preempt_enable打开时可能执行<code>__schedule</code></li></ul></li><li>正是因为主流的linux发行版不支持内核抢占,所以系统调用运行时间过长会导致应用程序处理延迟,因为一直要等到临近返回用户态时才主动调度出去</li></ul></li></ul></li></ol><p>无论主动还是被动, 都会通过<code>schedule</code>把进程切出去, schedule --&gt; __schedule --&gt; context_switch --&gt; switch_to --&gt; __switch_to_asm --&gt;</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">switch_to</span><span class="token expression"><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>\t\t\t\t\t</span><span class="token punctuation">\\</span>\n<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>\t\t\t\t\t\t\t\t\t</span><span class="token punctuation">\\</span>\n\t<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">__switch_to_asm</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\t\t\t</span><span class="token punctuation">\\</span>\n<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>\n</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">SYM_FUNC_START</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>\n\t<span class="token comment">/*\n\t * Save callee-saved registers\n\t * This must match the order in inactive_task_frame\n\t */</span>\n\tpushq\t<span class="token operator">%</span>rbp\n\tpushq\t<span class="token operator">%</span>rbx\n\tpushq\t<span class="token operator">%</span>r12\n\tpushq\t<span class="token operator">%</span>r13\n\tpushq\t<span class="token operator">%</span>r14\n\tpushq\t<span class="token operator">%</span>r15\n\n\t<span class="token comment">/* switch stack */</span>\n\tmovq\t<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span>\n\tmovq\t<span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>rsi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp    \n\t<span class="token comment">/* 执行完这个命令之后, 后续操作都是在next这个进程的内核栈进行了 */</span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_STACKPROTECTOR</span></span>\n\tmovq\t<span class="token function">TASK_stack_canary</span><span class="token punctuation">(</span><span class="token operator">%</span>rsi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rbx\n\tmovq\t<span class="token operator">%</span>rbx<span class="token punctuation">,</span> <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>fixed_percpu_data<span class="token punctuation">)</span> <span class="token operator">+</span> stack_canary_offset\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_RETPOLINE</span></span>\n\t<span class="token comment">/*\n\t * When switching from a shallower to a deeper call stack\n\t * the RSB may either underflow or use entries populated\n\t * with userspace addresses. On CPUs where those concerns\n\t * exist, overwrite the RSB with entries which capture\n\t * speculative execution to prevent attack.\n\t */</span>\n\tFILL_RETURN_BUFFER <span class="token operator">%</span>r12<span class="token punctuation">,</span> RSB_CLEAR_LOOPS<span class="token punctuation">,</span> X86_FEATURE_RSB_CTXSW\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>\n\n\t<span class="token comment">/* restore callee-saved registers */</span>\n\tpopq\t<span class="token operator">%</span>r15\n\tpopq\t<span class="token operator">%</span>r14\n\tpopq\t<span class="token operator">%</span>r13\n\tpopq\t<span class="token operator">%</span>r12\n\tpopq\t<span class="token operator">%</span>rbx\n\tpopq\t<span class="token operator">%</span>rbp\n\n\tjmp\t__switch_to\n<span class="token function">SYM_FUNC_END</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>\n</code></pre></div>',81),p={render:function(n,s){return t}}}}]);