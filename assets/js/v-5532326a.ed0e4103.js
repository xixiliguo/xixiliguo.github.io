(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[939],{3648:(n,a,t)=>{"use strict";t.r(a),t.d(a,{data:()=>s});const s={key:"v-5532326a",path:"/algorithm/unionfind.html",title:"UnionFind并查集和相关题解",lang:"en-US",frontmatter:{title:"UnionFind并查集和相关题解",author:"Peter Wang"},excerpt:"",headers:[],filePathRelative:"algorithm/unionfind.md",git:{updatedTime:1639312953e3,contributors:[]}}},6139:(n,a,t)=>{"use strict";t.r(a),t.d(a,{default:()=>o});const s=(0,t(6252).uE)('<h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h1><p>并查集的go实现</p><div class="language-go ext-go"><pre class="language-go"><code>\n<span class="token keyword">type</span> UnionFind <span class="token keyword">struct</span> <span class="token punctuation">{</span>\n\tParent <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>\n\tRank   <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>\n\tCount  <span class="token builtin">int</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">func</span> <span class="token function">NewUnionFind</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>UnionFind <span class="token punctuation">{</span>\n\tun <span class="token operator">:=</span> <span class="token operator">&amp;</span>UnionFind<span class="token punctuation">{</span>\n\t\tParent<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span>\n\t\tRank<span class="token punctuation">:</span>   <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span>\n\t\tCount<span class="token punctuation">:</span>  n<span class="token punctuation">,</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>\n\t\tun<span class="token punctuation">.</span>Parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i\n\t\tun<span class="token punctuation">.</span>Rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">return</span> un\n<span class="token punctuation">}</span>\n\n<span class="token keyword">func</span> <span class="token punctuation">(</span>un <span class="token operator">*</span>UnionFind<span class="token punctuation">)</span> <span class="token function">Find</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">for</span> un<span class="token punctuation">.</span>Parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x <span class="token punctuation">{</span>\n\t\tx <span class="token operator">=</span> un<span class="token punctuation">.</span>Parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">return</span> x\n<span class="token punctuation">}</span>\n\n<span class="token keyword">func</span> <span class="token punctuation">(</span>un <span class="token operator">*</span>UnionFind<span class="token punctuation">)</span> <span class="token function">Union</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\trootX <span class="token operator">:=</span> un<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n\trootY <span class="token operator">:=</span> un<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>\n\t<span class="token keyword">if</span> rootX <span class="token operator">==</span> rootY <span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">if</span> un<span class="token punctuation">.</span>Rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&gt;</span> un<span class="token punctuation">.</span>Rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token punctuation">{</span>\n\t\tun<span class="token punctuation">.</span>Parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX\n\t<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> un<span class="token punctuation">.</span>Rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> un<span class="token punctuation">.</span>Rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token punctuation">{</span>\n\t\tun<span class="token punctuation">.</span>Parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY\n\t<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n\t\tun<span class="token punctuation">.</span>Parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX\n\t\tun<span class="token punctuation">.</span>Rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span><span class="token operator">++</span>\n\t<span class="token punctuation">}</span>\n\tun<span class="token punctuation">.</span>Count<span class="token operator">--</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">func</span> <span class="token punctuation">(</span>un <span class="token operator">*</span>UnionFind<span class="token punctuation">)</span> <span class="token function">IsConnected</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>\n\trootX <span class="token operator">:=</span> un<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n\trootY <span class="token operator">:=</span> un<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>\n\t<span class="token keyword">return</span> rootX <span class="token operator">==</span> rootY\n<span class="token punctuation">}</span>\n</code></pre></div><h1 id="_1319-连通网络的操作次数" tabindex="-1"><a class="header-anchor" href="#_1319-连通网络的操作次数" aria-hidden="true">#</a> 1319. 连通网络的操作次数</h1><div class="language-golang ext-golang"><pre class="language-golang"><code>func makeConnected(n int, connections [][]int) int {\n\t// len(connections)是现有的线缆数,如果小于机器数-1, 那么无论如何都是无法连接所有机器的\n\tif len(connections) &lt; n-1 {\n\t\treturn -1\n\t}\n\tun := NewUnionFind(n)\n\tfor _, c := range connections {\n\t\tun.Union(c[0], c[1])\n\t}\n\treturn un.Count - 1\n}\n</code></pre></div><h1 id="_547-省份数量" tabindex="-1"><a class="header-anchor" href="#_547-省份数量" aria-hidden="true">#</a> 547. 省份数量</h1><div class="language-golang ext-golang"><pre class="language-golang"><code>func findCircleNum(isConnected [][]int) int {\n\tun := NewUnionFind(len(isConnected))\n\tfor i := 0; i &lt; len(isConnected); i++ {\n\t\tfor j := 0; j &lt; len(isConnected[i]); j++ {\n\t\t\tif isConnected[i][j] == 1 {\n\t\t\t\tun.Union(i, j)\n\n\t\t\t}\n\t\t}\n\t}\n\treturn un.Count\n\n}\n</code></pre></div><h1 id="_990-等式方程的可满足性" tabindex="-1"><a class="header-anchor" href="#_990-等式方程的可满足性" aria-hidden="true">#</a> 990. 等式方程的可满足性</h1><div class="language-golang ext-golang"><pre class="language-golang"><code>func equationsPossible(equations []string) bool {\n\n\tun := NewUnionFind(26)\n\tfor _, e := range equations {\n\t\tif e[1:3] == &quot;==&quot; {\n\t\t\tun.Union(int(e[0]-&#39;a&#39;), int(e[3]-&#39;a&#39;))\n\t\t}\n\t}\n\tfor _, e := range equations {\n\t\tif e[1:3] == &quot;!=&quot; {\n\t\t\tif un.IsConnected(int(e[0]-&#39;a&#39;), int(e[3]-&#39;a&#39;)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n</code></pre></div><h1 id="_399-除法求值" tabindex="-1"><a class="header-anchor" href="#_399-除法求值" aria-hidden="true">#</a> 399. 除法求值</h1><div class="language-golang ext-golang"><pre class="language-golang"><code>type NumUnionFind struct {\n\tParent map[string]string\n\tValue  map[string]float64\n\tBigParent map[string]string\n\tBigValue  map[string]float64\n}\n\nfunc (un NumUnionFind) Union(x, y string, value float64) {\n\t_, xok := un.Parent[x]\n\n\t_, yok := un.Parent[y]\n\tif xok &amp;&amp; !yok {\n\t\tun.Parent[y] = un.Find(x)\n\t\tun.Value[y] = 1 / value * un.Value[x]\n\n\t} else if !xok &amp;&amp; yok {\n\t\tun.Parent[x] = un.Find(y)\n\t\tun.Value[x] = value * un.Value[y]\n\t} else if !xok &amp;&amp; !yok {\n\t\tun.Parent[x] = y\n\t\tun.Value[x] = value\n\t\tun.Parent[y] = y\n\t\tun.Value[y] = 1\n\t} else {\n\t\txp := un.Parent[x]\n\t\typ := un.Parent[y]\n\t\tif xp != yp {\n\t\t\tun.Parent[xp] = yp\n\t\t\tun.Value[xp] = 1 / un.Value[x] * value * un.Value[y]\n\t\t\tfor k, v := range un.Parent {\n\t\t\t\tif v == xp {\n\t\t\t\t\tun.Parent[k] = yp\n\t\t\t\t\tun.Value[k] = un.Value[k] * un.Value[xp]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunc (un NumUnionFind) Isconnected(x, y string) bool {\n\tif _, ok := un.Parent[x]; !ok {\n\t\treturn false\n\t}\n\tif _, ok := un.Parent[y]; !ok {\n\t\treturn false\n\t}\n\treturn un.Find(x) == un.Find(y)\n}\n\nfunc (un NumUnionFind) Find(x string) string {\n\tfor un.Parent[x] != x {\n\t\tx = un.Parent[x]\n\t}\n\treturn x\n}\n\nfunc calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n\n\tun := NumUnionFind{\n\t\tmake(map[string]string),\n\t\tmake(map[string]float64),\n\t}\n\tfor i, v := range equations {\n\t\tun.Union(v[0], v[1], values[i])\n\t}\n\tres := make([]float64, 0)\n\tfor _, v := range queries {\n\t\tif un.Isconnected(v[0], v[1]) {\n\t\t\tres = append(res, un.Value[v[0]]*1/un.Value[v[1]])\n\t\t} else {\n\t\t\tres = append(res, -1.0)\n\t\t}\n\t}\n\treturn res\n\n}\n</code></pre></div><h1 id="_684-冗余连接" tabindex="-1"><a class="header-anchor" href="#_684-冗余连接" aria-hidden="true">#</a> 684. 冗余连接</h1><div class="language-golang ext-golang"><pre class="language-golang"><code>func findRedundantConnection(edges [][]int) []int {\n\tun := NewUnionFind(len(edges))\n\tpreCount := len(edges)\n\tfor i, edge := range edges {\n\t\tun.Union(edge[0]-1, edge[1]-1)\n\t\tif un.Count == preCount {\n\t\t\treturn edges[i]\n\t\t}\n\t\tpreCount = un.Count\n\t}\n\treturn []int{}\n}\n</code></pre></div><h1 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h1><p>https://segmentfault.com/a/1190000022952886</p>',15),o={render:function(n,a){return s}}}}]);