(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[512],{5539:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>t});const t={key:"v-0d3c509e",path:"/golang/golang-exec.html",title:"Golang os/exec 实现",lang:"en-US",frontmatter:{title:"Golang os/exec 实现",author:"Peter Wang",tags:["os/exec"],date:"2019-06-02T15:22:44.000Z",draft:!1},excerpt:"",headers:[],filePathRelative:"golang/golang-exec.md",git:{updatedTime:1626591395e3,contributors:[]}}},4659:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>o});const t=(0,a(6252).uE)('<p>os/exec 实现了golang调用shell或者其他OS中已存在的命令的方法. 本文主要是阅读内部实现后的一些总结.</p><h1 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h1><p>一. 如果要运行<code>ls -rlt</code>,代码如下:</p><div class="language-golang ext-golang"><pre class="language-golang"><code>package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;os/exec&quot;\n)\n\nfunc main() {\n\n\tcmd := exec.Command(&quot;ls&quot;, &quot;-rlt&quot;)\n\tstdoutStderr, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(&quot;%s\\n&quot;, stdoutStderr)\n}\n</code></pre></div><p>如果要运行<code>ls -rlt /root/*.go</code>, 使用<code>cmd := exec.Command(&quot;ls&quot;, &quot;-rlt&quot;, &quot;/root/*.go&quot;)</code>是错误的.<br> 因为底层是直接使用系统调用<code>execve</code>的.它并不会向Shell那样解析通配符. 变通方案为golang执行bash命令, 如:</p><div class="language-golang ext-golang"><pre class="language-golang"><code>package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;os/exec&quot;\n)\n\nfunc main() {\n\n\tcmd := exec.Command(&quot;bash&quot;, &quot;-c&quot;,&quot;ls -rlt /root/*.go&quot;)\n\tstdoutStderr, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(&quot;%s\\n&quot;, stdoutStderr)\n}\n</code></pre></div><p>二. 新进程默认继承父进程的环境变量, 要单独指定, 可以使用将类型为<code>[]string</code>的值赋给<code>cmd.Env</code>. 其行为不是增加, 是覆盖父进程的环境变量.<br> 三. 新进程的标准输入,标准输出,标准错误是可以指定随意配置的, 可以是文件, 也可以是<code>bytes.Buffer</code>这种满足<code>io.reader</code>或者<code>io.writer</code>的数据结构<br> 四. 默认新进程只有0,1,2三个文件描述符, 如果新进程想继承其他已打开的文件, 可以将它放入<code>cmd.ExtraFiles</code>. 该字段的英文解释如下:</p><div class="language-golang ext-golang"><pre class="language-golang"><code>// ExtraFiles specifies additional open files to be inherited by the\n// new process. It does not include standard input, standard output, or\n// standard error. If non-nil, entry i becomes file descriptor 3+i.\n//\n</code></pre></div><p>这里有例外, 如果golang程序时从其他进程拉起的, 那么父进程本身可能从父父进程继承了一些没有标记为close-exec的文件, 这个在<code>execve</code>时是无法close的.子进程仍然会继承.</p><h1 id="源码分析" tabindex="-1"><a class="header-anchor" href="#源码分析" aria-hidden="true">#</a> 源码分析</h1><p>一. os/exec是高阶库,大概的调用关系如下:</p><div class="language-text ext-text"><pre class="language-text"><code>                                                                 \n                         +----------------+                      \n                         | (*Cmd).Start() |                      \n                         +----------------+                      \n                                 |                               \n                                 v                               \n  +-------------------------------------------------------------+\n  | os.StartProcess(name string, argv []string, attr *ProcAttr) |\n  +-------------------------------------------------------------+\n                                 |                               \n                                 v                               \n          +-------------------------------------------+          \n          | syscall.StartProcess(name, argv, sysattr) |          \n          +-------------------------------------------+          \n</code></pre></div><p>二. (*Cmd).Start()主要处理如何与创建后的通信. 比如如何将一个文件内容作为子进程的标准输入, 如何获取子进程的标准输出. 具体创建进程在<code>os.StartProcess</code>里实现<br> 如下是处理子进程标准输入的具体代码注释.</p><div class="language-golang ext-golang"><pre class="language-golang"><code>// 该函数返回子进程标准输入对应的文件信息. 在fork/exec后子进程里面将其对应的文件描述符设置为0\nfunc (c *Cmd) stdin() (f *os.File, err error) {\n    // 如果没有定义的标准输入来源, 则默认是/dev/null\n\tif c.Stdin == nil {\n\t\tf, err = os.Open(os.DevNull)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tc.closeAfterStart = append(c.closeAfterStart, f)\n\t\treturn\n\t}\n\n    // 如果定义子进程的标准输入为父进程已打开的文件, 则直接返回\n\tif f, ok := c.Stdin.(*os.File); ok {\n\t\treturn f, nil\n\t}\n\n    // 如果是其他的,比如实现了io.Reader的一段字符串, 则通过pipe从父进程传入子进程\n    // 创建pipe, 成功execve后,在父进程里关闭读. 从父进程写, 从子进程读.\n    // 一旦父进程获取子进程的结果, 即子进程运行结束, 在父进程里关闭写.\n\tpr, pw, err := os.Pipe()\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// 读端对父进程没有用,一旦子进程创建出来继承后, 父进程关闭它\n\tc.closeAfterStart = append(c.closeAfterStart, pr)\n\t// 父进程要等子进程运行结束后,才能将写端关闭, 因为子进程不存在了,不需要读了\n    c.closeAfterWait = append(c.closeAfterWait, pw)\n    \n    // 通过goroutine将c.Stdin的数据写入到pipe的写端\n\tc.goroutine = append(c.goroutine, func() error {\n\t\t_, err := io.Copy(pw, c.Stdin)\n\t\tif skip := skipStdinCopyError; skip != nil &amp;&amp; skip(err) {\n\t\t\terr = nil\n\t\t}\n\t\tif err1 := pw.Close(); err == nil {\n\t\t\terr = err1\n\t\t}\n\t\treturn err\n\t})\n\treturn pr, nil\n}\n</code></pre></div><p>三. golang里使用<code>os.OpenFile</code>打开的文件默认是`close-on-exec&quot;<br> 除非它被指定为子进程的标准输入,标准输出或者标准错误输出, 否则在子进程里会被close掉.</p><p><code>file_unix.go</code>里是打开文件的逻辑:</p><div class="language-golang ext-golang"><pre class="language-golang"><code>// openFileNolog is the Unix implementation of OpenFile.\n// Changes here should be reflected in openFdAt, if relevant.\nfunc openFileNolog(name string, flag int, perm FileMode) (*File, error) {\n\tsetSticky := false\n\tif !supportsCreateWithStickyBit &amp;&amp; flag&amp;O_CREATE != 0 &amp;&amp; perm&amp;ModeSticky != 0 {\n\t\tif _, err := Stat(name); IsNotExist(err) {\n\t\t\tsetSticky = true\n\t\t}\n\t}\n\n\tvar r int\n\tfor {\n\t\tvar e error\n\t\tr, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))\n\t\tif e == nil {\n\t\t\tbreak\n\t\t}\n\n</code></pre></div><p>如果要让子进程继承指定的文件, 需要使用<code>ExtraFiles</code>字段</p><div class="language-golang ext-golang"><pre class="language-golang"><code>func main() {\n\ta, _ := os.Create(&quot;abc&quot;)\n\tcmd := exec.Command(&quot;ls&quot;, &quot;-rlt&quot;, &quot;/proc/self/fd&quot;)\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, a)\n\tstdoutStderr, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(&quot;%s\\n&quot;, stdoutStderr)\n}\n</code></pre></div><p>关于文件描述符(the processes&#39; local file descriptor table)和系统级的文件打开表(OS&#39; open file table)的关系, 可参见文章 https://www.cnblogs.com/Orgliny/articles/5699479.html<br> 如果两个文件描述符指向同一个文件打开项, 则共享打开的标志, 偏移量. (close-exec 是进程级文件描述符里的标志)<br> 每次<code>open</code>都会创建一个新的文件打开项, 所以同一个进程打开同一个文件两次, 那么文件打开项是不一样的. 不共享偏移量等信息</p><p>四. 当父进程内存特别大的时候, fork/exec的性能非常差, golang使用clone系统调优并大幅优化性能. 主要思路是创建的子进程和父进程初始时共用堆栈,fork则是复制一份堆栈. 具体代码如下:</p><div class="language-golang ext-golang"><pre class="language-golang"><code>\tlocked = true\n\tswitch {\n\tcase runtime.GOARCH == &quot;amd64&quot; &amp;&amp; sys.Cloneflags&amp;CLONE_NEWUSER == 0:\n\t\tr1, err1 = rawVforkSyscall(SYS_CLONE, uintptr(SIGCHLD|CLONE_VFORK|CLONE_VM)|sys.Cloneflags)\n\tcase runtime.GOARCH == &quot;s390x&quot;:\n\t\tr1, _, err1 = RawSyscall6(SYS_CLONE, 0, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0)\n\tdefault:\n\t\tr1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)\n\t}\n</code></pre></div><p>网上有很多关于讨论该性能的文章:<br> https://zhuanlan.zhihu.com/p/47940999<br> https://about.gitlab.com/2018/01/23/how-a-fix-in-go-19-sped-up-our-gitaly-service-by-30x/<br> https://github.com/golang/go/issues/5838<br> 如果是C语言, 可以使用<code>posix_spawn</code>代替<code>fork/exec</code>.<br><code>posix_spawn_file_actions_adddup2</code>,<code>posix_spawn_file_actions_addclose</code>,<code>posix_spawn_file_actions_addopen</code>等可以操作继承的文件描述符, 达到改变子进程0,1,2等目的. 详细的参考代码可见 https://github.com/rtomayko/posix-spawn/blob/master/ext/posix-spawn.c</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>\n\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;spawn.h&gt;</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>\n\n<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span>\n\n<span class="token keyword">void</span> <span class="token function">run_cmd_posix_spawn</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> status<span class="token punctuation">;</span>\n\n    status <span class="token operator">=</span> <span class="token function">posix_spawn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        <span class="token comment">// printf(&quot;Child pid: %i\\n&quot;, pid);</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n        <span class="token punctuation">{</span>\n            <span class="token comment">// printf(&quot;Child exited with status %i\\n&quot;, status);</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">else</span>\n        <span class="token punctuation">{</span>\n            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;waitpid&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">else</span>\n    <span class="token punctuation">{</span>\n        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;posix_spawn: %s\\n&quot;</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">void</span> <span class="token function">run_cmd_fork_exec</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>\n    <span class="token keyword">int</span> status<span class="token punctuation">;</span>\n\n    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        <span class="token comment">// printf(&quot;Child process pid = %u\\n&quot;, getpid());</span>\n        <span class="token function">execv</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">else</span>\n    <span class="token punctuation">{</span>\n        <span class="token comment">// printf(&quot;Parent process\\n&quot;);</span>\n\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n        <span class="token punctuation">{</span>\n\n            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">{</span>\n                <span class="token comment">// printf(&quot;program execution successfull\\n&quot;);</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">{</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">127</span><span class="token punctuation">)</span>\n                <span class="token punctuation">{</span>\n\n                    <span class="token comment">// execv failed</span>\n                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;execv failed\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span>\n                <span class="token keyword">else</span>\n                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;program terminated normally,&quot;</span>\n                           <span class="token string">&quot; but returned a non-zero status\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">else</span>\n                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;program didn&#39;t terminate normally\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">else</span>\n        <span class="token punctuation">{</span>\n            <span class="token comment">// waitpid() failed</span>\n            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;waitpid() failed\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">int</span> i<span class="token punctuation">;</span>\n    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Run command: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">clock_t</span> start<span class="token punctuation">,</span> finish<span class="token punctuation">;</span>\n    <span class="token keyword">double</span> duration<span class="token punctuation">;</span>\n\n    <span class="token keyword">int</span> loop <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>\n\n    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loop<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        <span class="token function">run_cmd_posix_spawn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    finish <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    duration <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>finish <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC <span class="token operator">/</span> loop<span class="token punctuation">;</span>\n    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;posix_spawn:  %d times:  %f seconds per one count\\n&quot;</span><span class="token punctuation">,</span> loop<span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loop<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        <span class="token function">run_cmd_fork_exec</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    finish <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    duration <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>finish <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC <span class="token operator">/</span> loop<span class="token punctuation">;</span>\n    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;fork/exec:  %d times:  %f seconds per one count\\n&quot;</span><span class="token punctuation">,</span> loop<span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>五. 父进程使用pipe来探测在创建子进程execve时是否有异常.<br> 在 syscall/exec_unix.go中.<br> 如果execve成功,则该pipe因close-on-exec在子进程里自动关闭. 父进程从pipe读到的长度为0<br> 如果有异常, 则将错误写入pipd的写端, 父进程读到长度非0的信息, 然后进行下一步处理</p><div class="language-golang ext-golang"><pre class="language-golang"><code>\t// Acquire the fork lock so that no other threads\n\t// create new fds that are not yet close-on-exec\n\t// before we fork.\n\tForkLock.Lock()\n\n\t// Allocate child status pipe close on exec.\n\tif err = forkExecPipe(p[:]); err != nil {\n\t\tgoto error\n\t}\n\n\t// Kick off child.\n\tpid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])\n\tif err1 != 0 {\n\t\terr = Errno(err1)\n\t\tgoto error\n\t}\n\tForkLock.Unlock()\n\n\t// Read child error status from pipe.\n\tClose(p[1])\n\tn, err = readlen(p[0], (*byte)(unsafe.Pointer(&amp;err1)), int(unsafe.Sizeof(err1)))\n\tClose(p[0])\n\tif err != nil || n != 0 {\n\t\tif n == int(unsafe.Sizeof(err1)) {\n\t\t\terr = Errno(err1)\n\t\t}\n\t\tif err == nil {\n\t\t\terr = EPIPE\n\t\t}\n\n\t\t// Child failed; wait for it to exit, to make sure\n\t\t// the zombies don&#39;t accumulate.\n\t\t_, err1 := Wait4(pid, &amp;wstatus, 0, nil)\n\t\tfor err1 == EINTR {\n\t\t\t_, err1 = Wait4(pid, &amp;wstatus, 0, nil)\n\t\t}\n\t\treturn 0, err\n\t}\n\n\t// Read got EOF, so pipe closed on exec, so exec succeeded.\n\treturn pid, nil\n</code></pre></div><p>六. 当子进程运行完后, 使用系统调用<code>wait4</code>回收资源, 可获取<code>exit code</code>,<code>信号</code>和<code>rusage</code>使用量等信息.<br> 七. 有超时机制, 如下例子是子进程在5分钟没有运行时也返回. 不会长时间阻塞进程.</p><div class="language-golang ext-golang"><pre class="language-golang"><code>package main\n\nimport (\n\t&quot;context&quot;\n\t&quot;os/exec&quot;\n\t&quot;time&quot;\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\n\tdefer cancel()\n\n\tif err := exec.CommandContext(ctx, &quot;sleep&quot;, &quot;5&quot;).Run(); err != nil {\n\t\t// This will fail after 100 milliseconds. The 5 second sleep\n\t\t// will be interrupted.\n\t}\n}\n\n</code></pre></div><p>具体是使用<code>context</code>库实现超时机制. 一旦时间达到,就给子进程发送<code>kill</code>信号,强制中止它.</p><div class="language-golang ext-golang"><pre class="language-golang"><code>\tif c.ctx != nil {\n\t\tc.waitDone = make(chan struct{})\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase &lt;-c.ctx.Done():\n\t\t\t\tc.Process.Kill()\n\t\t\tcase &lt;-c.waitDone:\n\t\t\t}\n\t\t}()\n\t}\n</code></pre></div><p>八. 假设调用一个脚本A, A有会调用B. 如果此时golang程序超时kill掉A, 那么B就变为pid为1的进程的子进程.<br> 有时这并不是我们所希望的.因为真正导致长时间没返回结果的可能是B进程.所以更希望将A和B同时杀掉. 默认golang的<code>exec.CommandContext</code>无法实现.<br> 具体需要在创建子进程时使用<code>setpgid</code>,将进程组ID设置为进程ID. 子子进程会继承这个进程组ID, 最后超时kill时指定进程组ID, 会将该进程组内的所有进程都kill掉. 对应golang的代码为:</p><div class="language-golang ext-golang"><pre class="language-golang"><code>func main() {\n\n\tcmd := exec.Command(&quot;/root/sleep.sh&quot;)\n\tcmd.SysProcAttr = &amp;syscall.SysProcAttr{\n\t\tSetpgid: true,\n\t}\n\n\tstart := time.Now()\n\ttime.AfterFunc(30*time.Second, func() {\n\t\tsyscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)\n\t})\n\n\terr := cmd.Run()\n\tfmt.Printf(&quot;pid=%d duration=%s err=%s\\n&quot;, cmd.Process.Pid, time.Since(start), err)\n\n}\n</code></pre></div><p>参考:<br> https://medium.com/@felixge/killing-a-child-process-and-all-of-its-children-in-go-54079af94773</p>',33),o={render:function(n,s){return t}}}}]);