<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link rel="icon" type="image/jpg" href="/img/coast.jpg"><title>内存管理 | xixiliguo</title><meta name="description" content="stay hungry stay foolish"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.443127ae.js" as="script"><link rel="preload" href="/assets/css/styles.d5a7f181.css" as="style"><link rel="preload" href="/assets/js/838.91c535db.js" as="script"><link rel="preload" href="/assets/js/app.1ace75fc.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.d5a7f181.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><!----><span class="site-name">xixiliguo</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/linux/atop.md" class="nav-link" aria-label="Linux运维"><!--[--><!--]--> Linux运维 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/network/tcpdump-wireshark.md" class="nav-link" aria-label="网络协议"><!--[--><!--]--> 网络协议 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/golang/golang-exec.md" class="nav-link" aria-label="Golang笔记"><!--[--><!--]--> Golang笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/k8s/runc.md" class="nav-link" aria-label="容器与k8s"><!--[--><!--]--> 容器与k8s <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/algorithm/radix-tree.md" class="nav-link" aria-label="算法笔记"><!--[--><!--]--> 算法笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/kernel/linux-trap.md" class="nav-link" aria-label="内核分析"><!--[--><!--]--> 内核分析 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/others/lua-implemention-gc.md" class="nav-link" aria-label="杂项"><!--[--><!--]--> 杂项 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/linux/atop.md" class="nav-link" aria-label="Linux运维"><!--[--><!--]--> Linux运维 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/network/tcpdump-wireshark.md" class="nav-link" aria-label="网络协议"><!--[--><!--]--> 网络协议 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/golang/golang-exec.md" class="nav-link" aria-label="Golang笔记"><!--[--><!--]--> Golang笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/k8s/runc.md" class="nav-link" aria-label="容器与k8s"><!--[--><!--]--> 容器与k8s <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/algorithm/radix-tree.md" class="nav-link" aria-label="算法笔记"><!--[--><!--]--> 算法笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/kernel/linux-trap.md" class="nav-link" aria-label="内核分析"><!--[--><!--]--> 内核分析 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/others/lua-implemention-gc.md" class="nav-link" aria-label="杂项"><!--[--><!--]--> 杂项 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">内核分析</p><ul class=""><li><!--[--><a href="/kernel/kernel-syscall-sched.html" class="nav-link sidebar-item" aria-label="系统调用与进程调度"><!--[--><!--]--> 系统调用与进程调度 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="内存管理"><!--[--><!--]--> 内存管理 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html#分段" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="分段"><!--[--><!--]--> 分段 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html#虚拟地址映射" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="虚拟地址映射"><!--[--><!--]--> 虚拟地址映射 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html#进程空间" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="进程空间"><!--[--><!--]--> 进程空间 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html#用户态" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="用户态"><!--[--><!--]--> 用户态 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html#内核态" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="内核态"><!--[--><!--]--> 内核态 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-memory.html#物理分配" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="物理分配"><!--[--><!--]--> 物理分配 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/kernel/linux-trap.html" class="nav-link sidebar-item" aria-label="Linux: Trap"><!--[--><!--]--> Linux: Trap <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="分段" tabindex="-1"><a class="header-anchor" href="#分段" aria-hidden="true">#</a> 分段</h2><p>linux并没有利用分段实现虚拟内存, 但是却利用了dpl功能实现了权限控制. 用户态DPL是3, 内核态DPL是0, 当用户态程序 CPL为3时直接访问内核态的地址时，会因权限不足而报错。所以要通过syscal, int等特别指令触发切换, 这些指令会改变CPL值</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">DEFINE_PER_CPU_PAGE_ALIGNED</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gdt_page</span><span class="token punctuation">,</span> gdt_page<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>gdt <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token comment">/*
	 * We need valid kernel segments for data and code in long mode too
	 * IRET will check the segment types  kkeil 2000/10/28
	 * Also sysret mandates a special GDT layout
	 *
	 * TLS descriptors are currently at a different place compared to i386.
	 * Hopefully nobody expects them at a fixed place (Wine?)
	 */</span>
	<span class="token punctuation">[</span>GDT_ENTRY_KERNEL32_CS<span class="token punctuation">]</span>		<span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc09b</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">[</span>GDT_ENTRY_KERNEL_CS<span class="token punctuation">]</span>		<span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xa09b</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">[</span>GDT_ENTRY_KERNEL_DS<span class="token punctuation">]</span>		<span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc093</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER32_CS<span class="token punctuation">]</span>	<span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0fb</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_DS<span class="token punctuation">]</span>	<span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xc0f3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">[</span>GDT_ENTRY_DEFAULT_USER_CS<span class="token punctuation">]</span>	<span class="token operator">=</span> <span class="token function">GDT_ENTRY_INIT</span><span class="token punctuation">(</span><span class="token number">0xa0fb</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="虚拟地址映射" tabindex="-1"><a class="header-anchor" href="#虚拟地址映射" aria-hidden="true">#</a> 虚拟地址映射</h2><p>x86_64下面分页机制采用四级目录, 相关数据结构在<code>arch/x86/include/asm/pgtable_64_types.h</code> 如果cpu支持5级分页, 当前centos9会自动激活这个特性</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PGDIR_SHIFT</span>	<span class="token expression"><span class="token number">39</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PTRS_PER_PGD</span>	<span class="token expression"><span class="token number">512</span></span></span>
<span class="token comment">/*
 * 3rd level page
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUD_SHIFT</span>	<span class="token expression"><span class="token number">30</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PTRS_PER_PUD</span>	<span class="token expression"><span class="token number">512</span></span></span>

<span class="token comment">/*
 * PMD_SHIFT determines the size of the area a middle-level
 * page table can map
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PMD_SHIFT</span>	<span class="token expression"><span class="token number">21</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PTRS_PER_PMD</span>	<span class="token expression"><span class="token number">512</span></span></span>

<span class="token comment">/*
 * entries per page directory level
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PTRS_PER_PTE</span>	<span class="token expression"><span class="token number">512</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PMD_SIZE</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token function">_AC</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> UL<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PMD_SHIFT<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PMD_MASK</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>PMD_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUD_SIZE</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token function">_AC</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> UL<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PUD_SHIFT<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PUD_MASK</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>PUD_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PGDIR_SIZE</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token function">_AC</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> UL<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PGDIR_SHIFT<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PGDIR_MASK</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>PGDIR_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>x86_64的虚拟地址是64位, 但只使用48位用于映射到物理地址.因为处理器地址只有48条,要求内存地址48位到63位必须相同, 具体四级目录用到的位数如下:<br> PGD(9) + PUD(9) + PMD(9) + PTE(9) + 页内偏移(12)</p><p>查询当前系统一页的大小</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># getconf PAGE_SIZE</span>
<span class="token number">4096</span>
</code></pre></div><h2 id="进程空间" tabindex="-1"><a class="header-anchor" href="#进程空间" aria-hidden="true">#</a> 进程空间</h2><p>进程空间分为用户态地址空间和内核态地址空间, 32位下面用户态空间是3G, 内核态时1G. 分界线为宏<code>#define TASK_SIZE</code>, 这个定义了用户态空间的最大地址, 根据下面的宏, 计算出x86_64下面为<code>0x00007FFFFFFFF000</code></p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_SIZE</span>		<span class="token expression"><span class="token punctuation">(</span><span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_ADDR32<span class="token punctuation">)</span> <span class="token operator">?</span> </span><span class="token punctuation">\</span>
					<span class="token expression">IA32_PAGE_OFFSET <span class="token operator">:</span> TASK_SIZE_MAX<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_SIZE_MAX</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> __VIRTUAL_MASK_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_SIZE<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_5LEVEL</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__VIRTUAL_MASK_SHIFT</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token function">pgtable_l5_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">56</span> <span class="token operator">:</span> <span class="token number">47</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__VIRTUAL_MASK_SHIFT</span>	<span class="token expression"><span class="token number">47</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; struct mm_struct -x 0xffff99da00e79540 | grep size
    task_size = 0x7ffffffff000,
crash&gt;
</code></pre></div><p>x86_64下<br> 用户空间 0x0000000000000000 ~ 0x00007FFFFFFFF000 128T<br> 内核空间 0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF 128T<br> 0x00007FFFFFFFF000 到 0xFFFF800000000000 为空洞区域</p><p>在execve时,将该值设置到mm_struct上面去</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token comment">/* Set the new mm task size. We have to do that late because it may
	 * depend on TIF_32BIT which is only updated in flush_thread() on
	 * some architectures like powerpc
	 */</span>
	current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>task_size <span class="token operator">=</span> TASK_SIZE<span class="token punctuation">;</span>
</code></pre></div><div class="language-bash ext-sh"><pre class="language-bash"><code>crash<span class="token operator">&gt;</span> struct mm_struct.task_size -x 0xffff9f814be29f80
    task_size <span class="token operator">=</span> 0x7ffffffff000
crash<span class="token operator">&gt;</span>
</code></pre></div><p>在x86_64, 内核态从<code>0xffff888000000000</code> 开始映射整个物理内存</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__PAGE_OFFSET_BASE_L4</span>	<span class="token expression"><span class="token function">_AC</span><span class="token punctuation">(</span><span class="token number">0xffff888000000000</span><span class="token punctuation">,</span> UL<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_DYNAMIC_MEMORY_LAYOUT</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__PAGE_OFFSET</span>           <span class="token expression">page_offset_base</span></span>
</code></pre></div><p>如果打开了kaslr, 在<code>kernel_randomize_memory</code>里会对<code>page_offset_base</code>随机向上偏移一些位置, 如下是实际运行的cents8里的值:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>crash<span class="token operator">&gt;</span> px page_offset_base
page_offset_base <span class="token operator">=</span> <span class="token variable">$20</span> <span class="token operator">=</span> 0xffff9f7f40000000
crash<span class="token operator">&gt;</span>
</code></pre></div><p>参考文档: Documentation/x86/x86_64/mm.txt</p><h3 id="用户态" tabindex="-1"><a class="header-anchor" href="#用户态" aria-hidden="true">#</a> 用户态</h3><p>在load_elf_binary函数里 <code>setup_new_exec</code>里设置mm-&gt;mmap_base和mm-&gt;task_size, <code>kernel.randomize_va_space = 2</code>表示需要随机化部分区域的起始地址, 包括mmap, stack等<br><code>setup_arg_pages</code>里设置mm-&gt;arg_start和mm-&gt;start_stack, 此时这两个值一样<br><code>create_elf_tables</code> 重新设置了mm-&gt;start_stack<br> start_stack指栈底, 它与arg_start之前存放了一些信息, 比如执行命令的参数个数和每一个参数的具体字符串指针, 每一个环境变量的指针. arg_start ~ arg_end, env_start ~ env_end 之间才是真正存放这些数据的地方. 在程序内部改变这些指针值就能改变参数和环境变量信息</p><h3 id="内核态" tabindex="-1"><a class="header-anchor" href="#内核态" aria-hidden="true">#</a> 内核态</h3><p>page_offset_base开始的64T范围内是直接映射内存, 这些虚拟地址对应的物理地址就是 减去page_offset_base<br> page_offset_base默认是0xffff888000000000, 如果<code>CONFIG_RANDOMIZE_MEMORY=y</code>则会随机偏移些<br> 每个进程对应的task_struct分配在这个区域, 可以减去page_offset_base直接得到物理地址</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; vtop ffff9e68002398c0
VIRTUAL           PHYSICAL
ffff9e68002398c0  1002398c0

PGD DIRECTORY: ffffffffb2e10000
PAGE DIRECTORY: 1c601067
   PUD: 1c601d00 =&gt; 1c606067
   PMD: 1c606008 =&gt; 1057a9063
   PTE: 1057a91c8 =&gt; 8000000100239063
  PAGE: 100239000

      PTE         PHYSICAL   FLAGS
8000000100239063  100239000  (PRESENT|RW|ACCESSED|DIRTY|NX)

      PAGE        PHYSICAL      MAPPING       INDEX CNT FLAGS
ffffdba004008e40 100239000 dead000000000008        0  0 17ffffc0000000
crash&gt; px page_offset_base
page_offset_base = $15 = 0xffff9e6700000000
crash&gt; eval ffff9e68002398c0 - 0xffff9e6700000000
hexadecimal: 1002398c0
    decimal: 4297300160
      octal: 40010714300
     binary: 0000000000000000000000000000000100000000001000111001100011000000
crash&gt;
</code></pre></div><p>vmalloc_base从 0xffffc90000000000UL开始, 随机偏移后, 可通过如下命令获取当前值</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; px vmalloc_base
vmalloc_base = $16 = 0xffffb9cb00000000
crash&gt;
</code></pre></div><p>vmemmap_base从 0xffffea0000000000UL开始, 随机偏移后, 可通过如下命令获取当前值, 存放 struct page</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; px vmemmap_base
vmemmap_base = $17 = 0xffffdba000000000
crash&gt;
</code></pre></div><p>内核的代码段从__START_KERNEL_map开始, 对应的物理地址是减去 __START_KERNEL_map 加上 phys_base</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__START_KERNEL_map</span>	<span class="token expression"><span class="token function">_AC</span><span class="token punctuation">(</span><span class="token number">0xffffffff80000000</span><span class="token punctuation">,</span> UL<span class="token punctuation">)</span></span></span>
</code></pre></div><h2 id="物理分配" tabindex="-1"><a class="header-anchor" href="#物理分配" aria-hidden="true">#</a> 物理分配</h2><p>当前主流都是numa结构, 即一个CPU对应本地内存, 当本地内存不够, 再通过总线访问其他节点的内存. 内存管理的最小单位是页, 通常是4K, 它属于Zone, Zone属于node节点节. node节点就是numa节点</p><p>如下表示该OS可以支持 1&lt;&lt; 10 == 1024个numa节点</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grep CONFIG_NODES_SHIFT /boot/config-5.14.0-22.el9.x86_64</span>
<span class="token assign-left variable">CONFIG_NODES_SHIFT</span><span class="token operator">=</span><span class="token number">10</span>
</code></pre></div><p>一台4u8G的机器, 只有一个numa. cpu0~3属于node0</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># lscpu | grep NUMA</span>
NUMA node<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:                    <span class="token number">1</span>
NUMA node0 CPU<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:               <span class="token number">0</span>-3
</code></pre></div><p>node0里面的跟物理内存的相关的数据如下</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>node_data<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span>
<span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>node_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; p node_data[0]
$22 = (pg_data_t *) 0xffff94e6dffd1000
crash&gt;  struct pg_data_t.node_id,nr_zones,node_start_pfn,node_present_pages,node_spanned_pages -x 0xffff94e6dffd1000
  node_id = 0x0,
  nr_zones = 0x3,
  node_start_pfn = 0x1,              //从页号1开始
  node_present_pages = 0x1fff8e,     //该node管理0x1fff8e个可用的页. 
  node_spanned_pages = 0x21ffff,     //管理0x21ffff页(8G), 除了包含present_pages, 还包含了空洞的物理地址. 这些页不可用.
crash&gt; struct zone.name,zone_start_pfn,spanned_pages,present_pages,managed_pages -x ffff94e6dffd1000 5
  name = 0xffffffffa9fa3ed3 &quot;DMA&quot;,
  zone_start_pfn = 0x1,
  spanned_pages = 0xfff,
  present_pages = 0xf9e,
  managed_pages = {
    counter = 0xf00
  },

  name = 0xffffffffa9f4c32c &quot;DMA32&quot;,
  zone_start_pfn = 0x1000,
  spanned_pages = 0xff000,
  present_pages = 0xdeff0,
  managed_pages = {
    counter = 0xcaff0
  },

  name = 0xffffffffa9f4c222 &quot;Normal&quot;,
  zone_start_pfn = 0x100000,
  spanned_pages = 0x120000,
  present_pages = 0x120000,
  managed_pages = {
    counter = 0x1145ec
  },

  name = 0xffffffffa9f4c229 &quot;Movable&quot;,
  zone_start_pfn = 0x0,
  spanned_pages = 0x0,
  present_pages = 0x0,
  managed_pages = {
    counter = 0x0
  },

  name = 0xffffffffa9f9924d &quot;Device&quot;,
  zone_start_pfn = 0x0,
  spanned_pages = 0x0,
  present_pages = 0x0,
  managed_pages = {
    counter = 0x0
  },
crash&gt;
</code></pre></div><p>0x1fff8e个可用页等于 8388152K</p><div class="language-text ext-text"><pre class="language-text"><code>[root@localhost ~]# dmesg -T | grep Mem
[Sun Dec 26 11:12:09 2021] Memory: 3442876K/8388152K available (14345K kernel code, 5931K rwdata, 8944K rodata, 2656K init, 5448K bss, 556100K reserved, 0K cma-reserved)
</code></pre></div><p>上面可以看到64位下有三个zone, 分别是 DMA, DMA32, Normal<br> struct page代表一页, 页通过伙伴系统管理. 所有空闲页挂在11个页块链表上. 每个链表包含相同连续页的地址. 有 1、2、4、8、16、32、64、128、256、512 和 1024. 所以一次最大可申请1024个物理地址连续的页(即4M的内存). 这些链表存在struct zone.free_area<br> 第 i 个页块链表中，页块中页的数目为 2^i</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ORDER</span> <span class="token expression"><span class="token number">11</span></span></span>
</code></pre></div><p>order为i时, 意味着申请 2 ^ i 个连续页, 如果free_area[i]没有, 则去free_area[i+1]里面找, 依次类推</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">7/10/2022, 3:49:18 PM</span></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"> ← <a href="/kernel/kernel-syscall-sched.html" class="nav-link" aria-label="系统调用与进程调度"><!--[--><!--]--> 系统调用与进程调度 <!--[--><!--]--></a></span><span class="next"><a href="/kernel/linux-trap.html" class="nav-link" aria-label="Linux: Trap"><!--[--><!--]--> Linux: Trap <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.443127ae.js" defer></script><script src="/assets/js/838.91c535db.js" defer></script><script src="/assets/js/app.1ace75fc.js" defer></script>
  </body>
</html>
