<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link rel="icon" type="image/jpg" href="/img/coast.jpg"><title>系统调用与进程调度 | xixiliguo</title><meta name="description" content="stay hungry stay foolish"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.443127ae.js" as="script"><link rel="preload" href="/assets/css/styles.d5a7f181.css" as="style"><link rel="preload" href="/assets/js/838.91c535db.js" as="script"><link rel="preload" href="/assets/js/app.1ace75fc.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.d5a7f181.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><!----><span class="site-name">xixiliguo</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/linux/atop.md" class="nav-link" aria-label="Linux运维"><!--[--><!--]--> Linux运维 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/network/tcpdump-wireshark.md" class="nav-link" aria-label="网络协议"><!--[--><!--]--> 网络协议 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/golang/golang-exec.md" class="nav-link" aria-label="Golang笔记"><!--[--><!--]--> Golang笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/k8s/runc.md" class="nav-link" aria-label="容器与k8s"><!--[--><!--]--> 容器与k8s <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/algorithm/radix-tree.md" class="nav-link" aria-label="算法笔记"><!--[--><!--]--> 算法笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/kernel/linux-trap.md" class="nav-link" aria-label="内核分析"><!--[--><!--]--> 内核分析 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/others/lua-implemention-gc.md" class="nav-link" aria-label="杂项"><!--[--><!--]--> 杂项 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/linux/atop.md" class="nav-link" aria-label="Linux运维"><!--[--><!--]--> Linux运维 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/network/tcpdump-wireshark.md" class="nav-link" aria-label="网络协议"><!--[--><!--]--> 网络协议 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/golang/golang-exec.md" class="nav-link" aria-label="Golang笔记"><!--[--><!--]--> Golang笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/k8s/runc.md" class="nav-link" aria-label="容器与k8s"><!--[--><!--]--> 容器与k8s <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/algorithm/radix-tree.md" class="nav-link" aria-label="算法笔记"><!--[--><!--]--> 算法笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/kernel/linux-trap.md" class="nav-link" aria-label="内核分析"><!--[--><!--]--> 内核分析 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/others/lua-implemention-gc.md" class="nav-link" aria-label="杂项"><!--[--><!--]--> 杂项 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">内核分析</p><ul class=""><li><!--[--><a aria-current="page" href="/kernel/kernel-syscall-sched.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="系统调用与进程调度"><!--[--><!--]--> 系统调用与进程调度 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/kernel/kernel-syscall-sched.html#_64位下系统调用约定" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="64位下系统调用约定"><!--[--><!--]--> 64位下系统调用约定 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-syscall-sched.html#task-struct部分字段的含义" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="task_struct部分字段的含义"><!--[--><!--]--> task_struct部分字段的含义 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-syscall-sched.html#进程管理" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="进程管理"><!--[--><!--]--> 进程管理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/kernel/kernel-syscall-sched.html#调度细节" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="调度细节"><!--[--><!--]--> 调度细节 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/kernel/kernel-memory.html" class="nav-link sidebar-item" aria-label="内存管理"><!--[--><!--]--> 内存管理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/kernel/linux-trap.html" class="nav-link sidebar-item" aria-label="Linux: Trap"><!--[--><!--]--> Linux: Trap <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>记录一些关于内核系统调用和进程调度相关的知识点, 以5.14内核为例</p><h2 id="_64位下系统调用约定" tabindex="-1"><a class="header-anchor" href="#_64位下系统调用约定" aria-hidden="true">#</a> 64位下系统调用约定</h2><p>c语言的函数调用过程中:<br> RDI, RSI, RDX, RCX, R8, R9 分别代表第一个,二个,三个... 参数, RAX代表返回值<br> RBX, RSP, RBP, and R12–R15 是调用者保存寄存器, 意思是调用者先保存原先值,在子函数返回时需要恢复,以确保该寄存器的值没变</p><p>Linux系统调用时稍微有一点不同, 第三个参数不是放到RCX, 而是R10. RCX用于保存切换时用户态时的RIP</p><p>下面是golang在linux amd64的系统调用汇编</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token comment">// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)</span>
TEXT ·<span class="token function">Syscall6</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token operator">-</span><span class="token number">80</span>
	CALL	runtime·<span class="token function">entersyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	MOVQ	a1<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> DI
	MOVQ	a2<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> SI
	MOVQ	a3<span class="token operator">+</span><span class="token function">24</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> DX
	MOVQ	a4<span class="token operator">+</span><span class="token function">32</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> R10  <span class="token comment">// 存放第三个参数</span>
	MOVQ	a5<span class="token operator">+</span><span class="token function">40</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> R8
	MOVQ	a6<span class="token operator">+</span><span class="token function">48</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> R9
	MOVQ	trap<span class="token operator">+</span><span class="token function">0</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX	<span class="token comment">// syscall entry</span>
	SYSCALL
	CMPQ	AX<span class="token punctuation">,</span> $<span class="token number">0xfffffffffffff001</span>    <span class="token comment">// 判断AX 是否小于 MAX_ERRNO:-4095 , 是则成功 </span>
	JLS	ok6
	MOVQ	$<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	MOVQ	$<span class="token number">0</span><span class="token punctuation">,</span> r2<span class="token operator">+</span><span class="token function">64</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	NEGQ	AX
	MOVQ	AX<span class="token punctuation">,</span> err<span class="token operator">+</span><span class="token function">72</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>             <span class="token comment">// 错误时, 则负值变正值, 返回具体的错误码</span>
	CALL	runtime·<span class="token function">exitsyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	RET
ok6<span class="token punctuation">:</span>
	MOVQ	AX<span class="token punctuation">,</span> r1<span class="token operator">+</span><span class="token function">56</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	MOVQ	DX<span class="token punctuation">,</span> r2<span class="token operator">+</span><span class="token function">64</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	MOVQ	$<span class="token number">0</span><span class="token punctuation">,</span> err<span class="token operator">+</span><span class="token function">72</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>
	CALL	runtime·<span class="token function">exitsyscall</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
	RET
</code></pre></div><p>系统调用返回前, 会执行<code>callq</code>, 将有符号的4字节扩展为8字节. 比如0x80000000 变为 ffffffff80000000, 0x40000000仍是40000000<br> https://stackoverflow.com/questions/6555094/what-does-cltq-do-in-assembly<br> 所有系统调用的返回错误值范围为[-4095, -1], 所以可以无符号判断 RAX 小于 0xfffffffffffff001, 则为正常返回</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token comment">/*
 * Kernel pointers have redundant information, so we can use a
 * scheme where we can return either an error code or a normal
 * pointer with the same return value.
 *
 * This should be a per-architecture thing, to allow different
 * error and pointer decisions.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ERRNO</span>	<span class="token expression"><span class="token number">4095</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ASSEMBLY__</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">IS_ERR_VALUE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span>MAX_ERRNO<span class="token punctuation">)</span></span></span>
</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code> <span class="token operator">*</span> <span class="token operator">&lt;</span>__x64_sys_recv<span class="token operator">&gt;</span><span class="token operator">:</span>		<span class="token operator">&lt;</span><span class="token operator">--</span> syscall with <span class="token number">4</span> parameters
 <span class="token operator">*</span>	callq	<span class="token operator">&lt;</span>__fentry__<span class="token operator">&gt;</span>
 <span class="token operator">*</span>
 <span class="token operator">*</span>	mov	<span class="token number">0x70</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rdi	<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>di
 <span class="token operator">*</span>	mov	<span class="token number">0x68</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rsi	<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>si
 <span class="token operator">*</span>	mov	<span class="token number">0x60</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rdx	<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>dx
 <span class="token operator">*</span>	mov	<span class="token number">0x38</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">%</span>rcx	<span class="token operator">&lt;</span><span class="token operator">--</span> decode regs<span class="token operator">-&gt;</span>r10
 <span class="token operator">*</span>
 <span class="token operator">*</span>	xor	<span class="token operator">%</span>r9d<span class="token punctuation">,</span><span class="token operator">%</span>r9d	<span class="token operator">&lt;</span><span class="token operator">--</span> clear <span class="token operator">%</span>r9
 <span class="token operator">*</span>	xor	<span class="token operator">%</span>r8d<span class="token punctuation">,</span><span class="token operator">%</span>r8d	<span class="token operator">&lt;</span><span class="token operator">--</span> clear <span class="token operator">%</span>r8
 <span class="token operator">*</span>
 <span class="token operator">*</span>	callq	__sys_recvfrom	<span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token keyword">do</span> the actual work in <span class="token function">__sys_recvfrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">*</span>				    which takes <span class="token number">6</span> arguments
 <span class="token operator">*</span>
 <span class="token operator">*</span>	cltq			<span class="token operator">&lt;</span><span class="token operator">--</span> extend <span class="token keyword">return</span> value to <span class="token number">64</span><span class="token operator">-</span>bit
 <span class="token operator">*</span>	retq			<span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token keyword">return</span>
 <span class="token operator">*</span>
</code></pre></div><p>64位下不是通过INT 0x80, 而是通过syscall指令触发系统调用, 对应的函数为<code>entry_SYSCALL_64</code>, 在这个函数里, 用户态的很多原始信息,比如rip,rsp都保存在<code>struct pt_regs</code>里, 然后 entry_SYSCALL_64 --&gt; do_syscall_64<br> 通过给<code>MSR_LSTAR</code>寄存器写入entry_SYSCALL_64地址, 那么执行syscall指令时就是切换到汇编entry_SYSCALL_64</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token function">wrmsr</span><span class="token punctuation">(</span>MSR_STAR<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>__USER32_CS <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> __KERNEL_CS<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将用户态时的rsp保存到per cpu变量cpu_tss_rw里面, 切换cpu为内核模式, 然后依次将寄存器里的值push, 填充pt_regs结构体. 保存所有用户态相关的信息<br> 从代码上看, 执行do_syscall_64前中断是关闭的, 在<code>syscall_enter_from_user_mode</code>里打开, 从<code>do_syscall_64</code>返回时又关闭了, 等执行了sysret后应该又打开了</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">SYM_CODE_START</span><span class="token punctuation">(</span>entry_SYSCALL_64<span class="token punctuation">)</span>
	UNWIND_HINT_EMPTY

	swapgs
	<span class="token comment">/* tss.sp2 is scratch space. */</span>
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>cpu_tss_rw <span class="token operator">+</span> TSS_sp2<span class="token punctuation">)</span>
	SWITCH_TO_KERNEL_CR3 scratch_reg<span class="token operator">=</span><span class="token operator">%</span>rsp
	movq	<span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>cpu_current_top_of_stack<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp

<span class="token function">SYM_INNER_LABEL</span><span class="token punctuation">(</span>entry_SYSCALL_64_safe_stack<span class="token punctuation">,</span> SYM_L_GLOBAL<span class="token punctuation">)</span>

	<span class="token comment">/* Construct struct pt_regs on stack */</span>
	pushq	$__USER_DS				<span class="token comment">/* pt_regs-&gt;ss */</span>
	pushq	<span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>cpu_tss_rw <span class="token operator">+</span> TSS_sp2<span class="token punctuation">)</span>	<span class="token comment">/* pt_regs-&gt;sp */</span>
	pushq	<span class="token operator">%</span>r11					<span class="token comment">/* pt_regs-&gt;flags */</span>
	pushq	$__USER_CS				<span class="token comment">/* pt_regs-&gt;cs */</span>
	pushq	<span class="token operator">%</span>rcx					<span class="token comment">/* pt_regs-&gt;ip */</span>
<span class="token function">SYM_INNER_LABEL</span><span class="token punctuation">(</span>entry_SYSCALL_64_after_hwframe<span class="token punctuation">,</span> SYM_L_GLOBAL<span class="token punctuation">)</span>
	pushq	<span class="token operator">%</span>rax					<span class="token comment">/* pt_regs-&gt;orig_ax */</span>

	PUSH_AND_CLEAR_REGS rax<span class="token operator">=</span>$<span class="token operator">-</span>ENOSYS

	<span class="token comment">/* IRQs are off. */</span>
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token operator">%</span>rdi
	<span class="token comment">/* Sign extend the lower 32bit as syscall numbers are treated as int */</span>
	movslq	<span class="token operator">%</span>eax<span class="token punctuation">,</span> <span class="token operator">%</span>rsi
	call	do_syscall_64		<span class="token comment">/* returns with IRQs disabled */</span>
</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code>__visible noinstr <span class="token keyword">void</span> <span class="token function">do_syscall_64</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">add_random_kstack_offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	nr <span class="token operator">=</span> <span class="token function">syscall_enter_from_user_mode</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* syscall_enter_from_user_mode里面会检查一些权限, 比如是否满足SECCOMP. 对系统调用的审计也在这里 
	 * 如果返回-1, 则不会执行下面的函数, 最终给用户态程序返回 -ENOSYS
	*/</span>

	<span class="token function">instrumentation_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">do_syscall_x64</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> nr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">do_syscall_x32</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> nr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nr <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">/* Invalid system call, but still a system call. */</span>
		regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> <span class="token function">__x64_sys_ni_syscall</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">instrumentation_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">syscall_exit_to_user_mode</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所有的系统调用的具体实现函数, 汇总到<code>sys_call_table</code>,同时<code>arch/x86/entry/syscalls/syscall_64.tbl</code> 里也可以直接查询系统调用号与具体实现函数名的对应关系</p><div class="language-c ext-c"><pre class="language-c"><code>crash<span class="token operator">&gt;</span> whatis sys_call_table
<span class="token keyword">const</span> <span class="token class-name">sys_call_ptr_t</span> sys_call_table<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
crash<span class="token operator">&gt;</span> p sys_call_table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
$<span class="token number">9</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">sys_call_ptr_t</span><span class="token punctuation">)</span> <span class="token number">0xffffffffb9b19c30</span>
crash<span class="token operator">&gt;</span> sym <span class="token number">0xffffffffb9b19c30</span>
<span class="token function">ffffffffb9b19c30</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> __x64_sys_read <span class="token operator">/</span>usr<span class="token operator">/</span>src<span class="token operator">/</span>debug<span class="token operator">/</span>kernel<span class="token operator">-</span><span class="token number">4.18</span><span class="token number">.0</span><span class="token operator">-</span><span class="token number">305.3</span><span class="token number">.1</span><span class="token punctuation">.</span>el8_4<span class="token operator">/</span>linux<span class="token operator">-</span><span class="token number">4.18</span><span class="token number">.0</span><span class="token operator">-</span><span class="token number">305.3</span><span class="token number">.1</span><span class="token punctuation">.</span>el8<span class="token punctuation">.</span>x86_64<span class="token operator">/</span>fs<span class="token operator">/</span>read_write<span class="token punctuation">.</span>c<span class="token operator">:</span> <span class="token number">586</span>
crash<span class="token operator">&gt;</span>
</code></pre></div><p><code>syscall_exit_to_user_mode -&gt; __syscall_exit_to_user_mode_work --&gt; exit_to_user_mode_prepare --&gt; exit_to_user_mode_loop</code>, 在exit_to_user_mode_loop里有一些重要的事情要做.<br> 如果该进程被标记为需要调度,即需要让出cpu,让其他进程执行<br> 该进程收到信号需要处理, 也是在退出syscall返回用户态空间前执行的</p><p><code>mov 0x38(%rdi),%ecx</code> 可以看到确实是将陷入内核态前的R10(代表第三个参数)赋值给RCX, 满足后续C语言的调用规约</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; dis -l __x64_sys_recv
/usr/src/debug/kernel-5.14.0-22.el9/linux-5.14.0-22.el9.x86_64/net/socket.c: 2111
0xffffffffa21f4400 &lt;__x64_sys_recv&gt;:    nopl   0x0(%rax,%rax,1) [FTRACE NOP]
/usr/src/debug/kernel-5.14.0-22.el9/linux-5.14.0-22.el9.x86_64/net/socket.c: 2114
0xffffffffa21f4405 &lt;__x64_sys_recv+5&gt;:  mov    0x60(%rdi),%rdx
0xffffffffa21f4409 &lt;__x64_sys_recv+9&gt;:  mov    0x68(%rdi),%rsi
0xffffffffa21f440d &lt;__x64_sys_recv+13&gt;: xor    %r9d,%r9d
0xffffffffa21f4410 &lt;__x64_sys_recv+16&gt;: xor    %r8d,%r8d
0xffffffffa21f4413 &lt;__x64_sys_recv+19&gt;: mov    0x38(%rdi),%ecx
0xffffffffa21f4416 &lt;__x64_sys_recv+22&gt;: mov    0x70(%rdi),%edi
0xffffffffa21f4419 &lt;__x64_sys_recv+25&gt;: call   0xffffffffa21f4210 &lt;__sys_recvfrom&gt;
/usr/src/debug/kernel-5.14.0-22.el9/linux-5.14.0-22.el9.x86_64/net/socket.c: 2111
0xffffffffa21f441e &lt;__x64_sys_recv+30&gt;: cltq
0xffffffffa21f4420 &lt;__x64_sys_recv+32&gt;: ret
crash&gt; struct pt_regs -xo | grep 0x38
  [0x38] unsigned long r10;
crash&gt;
</code></pre></div><p><code>sysretq</code>指令从RCS载入值到RIP, 返回用户态</p><p>从代码中搜索系统调用具体函数的技巧: 以open为例, 它有三个参数, 则通过<code>define3(open</code> 就能很快找到对应的实现</p><p>参考:<br> http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/<br> https://en.wikipedia.org/wiki/X86_calling_conventions<br> https://cloud.tencent.com/developer/article/1492374</p><h2 id="task-struct部分字段的含义" tabindex="-1"><a class="header-anchor" href="#task-struct部分字段的含义" aria-hidden="true">#</a> task_struct部分字段的含义</h2><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
u64        utime<span class="token punctuation">;</span><span class="token comment">//用户态消耗的CPU时间</span>
u64        stime<span class="token punctuation">;</span><span class="token comment">//内核态消耗的CPU时间</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      nvcsw<span class="token punctuation">;</span><span class="token comment">//自愿(voluntary)上下文切换计数</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      nivcsw<span class="token punctuation">;</span><span class="token comment">//非自愿(involuntary)上下文切换计数</span>
u64        start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，不包含睡眠时间</span>
u64        real_start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，包含睡眠时间</span>
<span class="token punctuation">}</span>
</code></pre></div><p>utime, stime单位为ns, 两次时钟中断触发的时间间隔为<code>1/HZ</code>. 内核里面HZ一般是1000,(centos是1000, ubuntu是250), 在函数<code>account_process_tick</code>里每次更新utime,stime都是增加<code>TICK_NSEC</code> - steal-time`, TICK_NSEC为1000000,</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># grep CONFIG_HZ= /boot/config-5.14.0-22.el9.x86_64</span>
<span class="token assign-left variable">CONFIG_HZ</span><span class="token operator">=</span><span class="token number">1000</span>
</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code>
<span class="token comment">/* TICK_NSEC is the time between ticks in nsec assuming SHIFTED_HZ */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TICK_NSEC</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>NSEC_PER_SEC<span class="token operator">+</span>HZ<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">/</span>HZ<span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Account a tick to a process and cpustat
 * @p: the process that the CPU time gets accounted to
 * @user_tick: is the tick from userspace
 * @rq: the pointer to rq
 *
 * Tick demultiplexing follows the order
 * - pending hardirq update
 * - pending softirq update
 * - user_time
 * - idle_time
 * - system time
 *   - check for guest_time
 *   - else account as system_time
 *
 * Check for hardirq is done both for system and user time as there is
 * no timer going off while we are on hardirq and hence we may never get an
 * opportunity to update it solely in system time.
 * p-&gt;stime and friends are only updated on system time and not on irq
 * softirq as those do not count in task exec_runtime any more.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">irqtime_account_process_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> user_tick<span class="token punctuation">,</span>
					 <span class="token keyword">int</span> ticks<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	u64 other<span class="token punctuation">,</span> cputime <span class="token operator">=</span> TICK_NSEC <span class="token operator">*</span> ticks<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * When returning from idle, many ticks can get accounted at
	 * once, including some ticks of steal, irq, and softirq time.
	 * Subtract those ticks from the amount of time accounted to
	 * idle, or potentially user or system time. Due to rounding,
	 * other time can exceed ticks occasionally.
	 */</span>
	other <span class="token operator">=</span> <span class="token function">account_other_time</span><span class="token punctuation">(</span>ULONG_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">&gt;=</span> cputime<span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>

	cputime <span class="token operator">-=</span> other<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">this_cpu_ksoftirqd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">/*
		 * ksoftirqd time do not get accounted in cpu_softirq_time.
		 * So, we have to handle it separately here.
		 * Also, p-&gt;stime needs to be updated for ksoftirqd.
		 */</span>
		<span class="token function">account_system_index_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">,</span> CPUTIME_SOFTIRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>user_tick<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">account_user_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token function">this_rq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>idle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">account_idle_time</span><span class="token punctuation">(</span>cputime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> PF_VCPU<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* System time or guest time */</span>
		<span class="token function">account_guest_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">account_system_index_time</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cputime<span class="token punctuation">,</span> CPUTIME_SYSTEM<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大致的调用关系</p><div class="language-text ext-text"><pre class="language-text"><code>     	irqtime_account_process_tick+1
        update_process_times+81
        tick_sched_handle+34
        tick_sched_timer+97
        __hrtimer_run_queues+298
        hrtimer_interrupt+272
        __sysvec_apic_timer_interrupt+92
        sysvec_apic_timer_interrupt+55
        asm_sysvec_apic_timer_interrupt+18
</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code>update_process_times
	irqtime_account_process_tick     <span class="token comment">/* 更新cpu信息 */</span>
	scheduler_tick                   <span class="token comment">/* 更新调度相关的信息, 比如 vruntime */</span>
</code></pre></div><p>start_time, real_start_time单位是ns, 指自系统启动以来到进程创建时流逝的时间, 在<code>copy_process</code>里赋值</p><div class="language-text ext-text"><pre class="language-text"><code>	p-&gt;start_time = ktime_get_ns();
	p-&gt;real_start_time = ktime_get_boot_ns();
</code></pre></div><p>如下显示systemd进程时系统启动17ms后创建, 截止dump生成,以运行6小时多.</p><div class="language-bash ext-sh"><pre class="language-bash"><code>crash<span class="token operator">&gt;</span> <span class="token function">ps</span> -t <span class="token number">1</span>
PID: <span class="token number">1</span>      TASK: ffff8fb0c6dc2f80  CPU: <span class="token number">0</span>   COMMAND: <span class="token string">&quot;systemd&quot;</span>
    RUN TIME: 06:34:57
  START TIME: <span class="token number">17000000</span>
       UTIME: <span class="token number">1072507605</span>
       STIME: <span class="token number">1248244355</span>

crash<span class="token operator">&gt;</span>
</code></pre></div><p>我们在<code>/proc/[pid]/stat</code>里看到的utime 和 stime单位是clock ticks, 内核里HZ每个版本可能不一样, 但为了保持用户态的一致性,暴露给用户态的USER_HZ却一直都是100. 通过<code>nsec_to_clock_t</code> 将task_struct-&gt;utime,stime转化为<code>ticks</code>. 在centos8 x86_64环境为<code>x/( NSEC_PER_SEC / USER_HZ)</code></p><div class="language-c ext-c"><pre class="language-c"><code>u64 <span class="token class-name">nsec_to_clock_t</span><span class="token punctuation">(</span>u64 x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>NSEC_PER_SEC <span class="token operator">%</span> USER_HZ<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span></span></span>
	<span class="token keyword">return</span> <span class="token function">div_u64</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> NSEC_PER_SEC <span class="token operator">/</span> USER_HZ<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token punctuation">(</span>USER_HZ <span class="token operator">%</span> <span class="token number">512</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span></span></span>
	<span class="token keyword">return</span> <span class="token function">div_u64</span><span class="token punctuation">(</span>x <span class="token operator">*</span> USER_HZ <span class="token operator">/</span> <span class="token number">512</span><span class="token punctuation">,</span> NSEC_PER_SEC <span class="token operator">/</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
	<span class="token comment">/*
         * max relative error 5.7e-8 (1.8s per year) for USER_HZ &lt;= 1024,
         * overflow after 64.99 years.
         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...
         */</span>
	<span class="token keyword">return</span> <span class="token function">div_u64</span><span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9ull</span> <span class="token operator">*</span> NSEC_PER_SEC <span class="token operator">+</span> <span class="token punctuation">(</span>USER_HZ <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> USER_HZ<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>/proc/[pid]/stat</code>的具体实现在<code>fs/proc/array.c</code>里的<code>do_task_stat</code></p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token function">seq_put_decimal_ull</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span> <span class="token class-name">nsec_to_clock_t</span><span class="token punctuation">(</span>utime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">seq_put_decimal_ull</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span> <span class="token class-name">nsec_to_clock_t</span><span class="token punctuation">(</span>stime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>top</code>里显示cpu的hi和si在<code>irqtime_account_irq</code>计算, 该函数在irq_enter和irq_exit时运行. ksoftirq的处理时间不仅算在自己进程的stime上, 还会算到cpu的si上面</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_softirq_enter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">vtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> SOFTIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> SOFTIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/*更新starttime, 但第二个参数不让计算差值*/</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_softirq_exit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">vtime_account_softirq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">/*更新starttime, 并将差值(now-starttime)统计进去*/</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_hardirq_enter</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">vtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> HARDIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> HARDIRQ_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/*更新starttime, 但第二个参数不让计算差值*/</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">account_hardirq_exit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">vtime_account_hardirq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">irqtime_account_irq</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/*更新starttime, 并将差值(now-starttime)统计进去*/</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过task获取pt_regs的函数如下, 这里记录了进程进入内核态时, 保存的一些用户态信息.</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KASAN</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KASAN_STACK_ORDER</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KASAN_STACK_ORDER</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE_ORDER</span>	<span class="token expression"><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> KASAN_STACK_ORDER<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE</span>  <span class="token expression"><span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_pt_regs</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>									</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>	</span><span class="token punctuation">\</span>
	<span class="token expression">__ptr <span class="token operator">+=</span> THREAD_SIZE <span class="token operator">-</span> TOP_OF_KERNEL_STACK_PADDING<span class="token punctuation">;</span>		</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span><span class="token punctuation">)</span>__ptr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>					</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_VM86</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">8</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>


</code></pre></div><p>pid的类型为int,但pidmax默认值在kernel/pid.c里的<code>pid_idr_init</code>设置, 新分配的pid是上一次分配的pid加1, 直到pid_max, 然后循环使用已闲置的最小pid.</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">void</span> __init <span class="token function">pid_idr_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* Verify no one has done anything silly: */</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>PID_MAX_LIMIT <span class="token operator">&gt;=</span> PIDNS_ADDING<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* bump default and minimum pid_max based on number of cpus */</span>
	pid_max <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>pid_max_max<span class="token punctuation">,</span> <span class="token class-name">max_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> pid_max<span class="token punctuation">,</span>
				PIDS_PER_CPU_DEFAULT <span class="token operator">*</span> <span class="token function">num_possible_cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	pid_max_min <span class="token operator">=</span> <span class="token class-name">max_t</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> pid_max_min<span class="token punctuation">,</span>
				PIDS_PER_CPU_MIN <span class="token operator">*</span> <span class="token function">num_possible_cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">&quot;pid_max: default: %u minimum: %u\n&quot;</span><span class="token punctuation">,</span> pid_max<span class="token punctuation">,</span> pid_max_min<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">idr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>init_pid_ns<span class="token punctuation">.</span>idr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	init_pid_ns<span class="token punctuation">.</span>pid_cachep <span class="token operator">=</span> <span class="token function">KMEM_CACHE</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span>
			SLAB_HWCACHE_ALIGN <span class="token operator">|</span> SLAB_PANIC <span class="token operator">|</span> SLAB_ACCOUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果要通过<code>sysctl -w kernel.pid_max=xxx</code>调节, 64位下最大值为4194304. 一般CONFIG_BASE_SMALL为N.</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token comment">/*
 * A maximum of 4 million PIDs should be enough for a while.
 * [NOTE: PID/TIDs are limited to 2^29 ~= 500+ million, see futex.h.]
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PID_MAX_LIMIT</span> <span class="token expression"><span class="token punctuation">(</span>CONFIG_BASE_SMALL <span class="token operator">?</span> PAGE_SIZE <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">:</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">:</span> PID_MAX_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>在<code>copy_process</code>里先判断是否超过ulimit里面的限制, 但root用户的进程不受这个限制</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_ucounts_overlimit</span><span class="token punctuation">(</span><span class="token function">task_ucounts</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> UCOUNT_RLIMIT_NPROC<span class="token punctuation">,</span> <span class="token function">rlimit</span><span class="token punctuation">(</span>RLIMIT_NPROC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>real_cred<span class="token operator">-&gt;</span>user <span class="token operator">!=</span> INIT_USER <span class="token operator">&amp;&amp;</span>
		    <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_RESOURCE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">goto</span> bad_fork_free<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>如果当前的线程数(其实就是task_struct的数量, 在linux进程和线程其实是都是task_struct), 超过/proc/sys/kernel/threads-max, 也会报错</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token comment">/*
	 * If multiple threads are within copy_process(), then this check
	 * triggers too late. This doesn&#39;t hurt, the check is only there
	 * to stop root fork bombs.
	 */</span>
	retval <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">data_race</span><span class="token punctuation">(</span>nr_threads <span class="token operator">&gt;=</span> max_threads<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_cleanup_count<span class="token punctuation">;</span>
</code></pre></div><p>紧接着如果因超过pid_max, 且没闲置的pid, 则会导致创建进程失败.</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> <span class="token operator">&amp;</span>init_struct_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		pid <span class="token operator">=</span> <span class="token function">alloc_pid</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>nsproxy<span class="token operator">-&gt;</span>pid_ns_for_children<span class="token punctuation">,</span> args<span class="token operator">-&gt;</span>set_tid<span class="token punctuation">,</span>
				args<span class="token operator">-&gt;</span>set_tid_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			retval <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">goto</span> bad_fork_cleanup_thread<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>最后还会检查cgroup里的的pid_max限制</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token comment">/*
	 * Ensure that the cgroup subsystem policies allow the new process to be
	 * forked. It should be noted that the new process&#39;s css_set can be changed
	 * between here and cgroup_post_fork() if an organisation operation is in
	 * progress.
	 */</span>
	retval <span class="token operator">=</span> <span class="token function">cgroup_can_fork</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> bad_fork_put_pidfd<span class="token punctuation">;</span>

</code></pre></div><p>日志里面有如下报错,就是因为这个原因<br> cgroup: fork rejected by pids controller in /user.slice/user-0.slice/session-7.scope</p><p>我们再来看经常遇到的超过文件句柄数相关的一些知识<br> 通过<code>ulimit -n</code>设置进程最大的打开文件数, 最大值为<code>1048576</code>, 它是受限于<code>sysctl fs.nr_open</code></p><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_nr_open __read_mostly <span class="token operator">=</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span>   <span class="token comment">//默认值</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_nr_open_min <span class="token operator">=</span> BITS_PER_LONG<span class="token punctuation">;</span>
<span class="token comment">/* our min() is unusable in constant expressions ;-/ */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__const_min</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_nr_open_max <span class="token operator">=</span>
	<span class="token function">__const_min</span><span class="token punctuation">(</span>INT_MAX<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">-</span>BITS_PER_LONG<span class="token punctuation">;</span>  <span class="token comment">//最大值</span>
</code></pre></div><p>有两个跟文件句柄数的报错, <code>ENFILE</code>表示超过了OS整的系统限制, <code>EMFILE</code>表示超过了自身的<code>/proc/[pid]/limits</code>里面<code>Max open files</code>的限制</p><div class="language-text ext-text"><pre class="language-text"><code>/usr/include/asm-generic/errno-base.h:#define   ENFILE          23      /* File table overflow */
/usr/include/asm-generic/errno-base.h:#define   EMFILE          24      /* Too many open files */
</code></pre></div><p>OS系统级所有打开的文件句柄最大数, 普通用户受限, 但root的进程不受限</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost abc<span class="token punctuation">]</span><span class="token comment"># sysctl fs.file-nr</span>
fs.file-nr <span class="token operator">=</span> <span class="token number">1984</span>       <span class="token number">0</span>       <span class="token number">789985</span>
<span class="token punctuation">[</span>root@localhost abc<span class="token punctuation">]</span><span class="token comment"># sysctl fs.file-max</span>
fs.file-max <span class="token operator">=</span> <span class="token number">789985</span>
<span class="token punctuation">[</span>root@localhost abc<span class="token punctuation">]</span><span class="token comment">#</span>
</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token function">alloc_empty_file</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token operator">*</span>cred<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">static</span> <span class="token keyword">long</span> old_max<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Privileged users can go above max_files
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_nr_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> files_stat<span class="token punctuation">.</span>max_files <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">capable</span><span class="token punctuation">(</span>CAP_SYS_ADMIN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">/*
		 * percpu_counters are inaccurate.  Do an expensive check before
		 * we go and fail.
		 */</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">percpu_counter_sum_positive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nr_files<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> files_stat<span class="token punctuation">.</span>max_files<span class="token punctuation">)</span>
			<span class="token keyword">goto</span> over<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	f <span class="token operator">=</span> <span class="token function">__alloc_file</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> cred<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">percpu_counter_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nr_files<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> f<span class="token punctuation">;</span>

over<span class="token operator">:</span>
	<span class="token comment">/* Ran out of filps - report that */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_nr_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> old_max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">&quot;VFS: file-max limit %lu reached\n&quot;</span><span class="token punctuation">,</span> <span class="token function">get_max_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		old_max <span class="token operator">=</span> <span class="token function">get_nr_files</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span><span class="token operator">-</span>ENFILE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>task_struct-&gt;stack 指向进程的内核栈, 在 dup_task_struct --&gt; alloc_thread_stack_node 里面分配, 通常是通过vmalloc分配, 而不是slab系统</p><div class="language-c ext-c"><pre class="language-c"><code>	<span class="token comment">/*
	 * Allocated stacks are cached and later reused by new threads,
	 * so memcg accounting is performed manually on assigning/releasing
	 * stacks to tasks. Drop __GFP_ACCOUNT.
	 */</span>
	stack <span class="token operator">=</span> <span class="token function">__vmalloc_node_range</span><span class="token punctuation">(</span>THREAD_SIZE<span class="token punctuation">,</span> THREAD_ALIGN<span class="token punctuation">,</span>
				     VMALLOC_START<span class="token punctuation">,</span> VMALLOC_END<span class="token punctuation">,</span>
				     THREADINFO_GFP <span class="token operator">&amp;</span> <span class="token operator">~</span>__GFP_ACCOUNT<span class="token punctuation">,</span>
				     PAGE_KERNEL<span class="token punctuation">,</span>
				     <span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * We can&#39;t call find_vm_area() in interrupt context, and
	 * free_thread_stack() can be called in interrupt context,
	 * so cache the vm_struct.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		tsk<span class="token operator">-&gt;</span>stack_vm_area <span class="token operator">=</span> <span class="token function">find_vm_area</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
		tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> stack<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; task | grep stack
  stack = 0xffff97c5825e0000,
  stack_canary = 2863369865746246656,
  curr_ret_stack = -1,
  ret_stack = 0x0,
  stack_vm_area = 0xffff8c900af5b040,
  stack_refcount = {
crash&gt; grep 0xffff97c5825e0000 /proc/vmallocinfo
0xffff97c5825e0000-0xffff97c5825e5000   20480 dup_task_struct+0x49/0x300 pages=4 vmalloc N0=4
crash&gt;
</code></pre></div><h2 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h2><p><code>current</code>永远指向当前cpu上运行的进程的task_struct, 实现方式如下</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">current</span> <span class="token expression"><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p><code>init_task</code>代表了pid为0的进程, 即swapper/0, 通过它和<code>task_struct.tasks</code>可以找到所有进程</p><div class="language-text ext-text"><pre class="language-text"><code>crash&gt; list task_struct.tasks -s task_struct.comm -h init_task | head -19
ffffffffb481a940
  comm = &quot;swapper/0\000\000\000\000\000\000&quot;,
ffff9dd300218000
  comm = &quot;systemd\000\060\000\000\000\000\000\000&quot;,
ffff9dd30021e300
  comm = &quot;kthreadd\000\000\000\000\000\000\000&quot;,
ffff9dd30021ca40
  comm = &quot;rcu_gp\000d\000\000\000\000\000\000\000&quot;,
ffff9dd3002198c0
  comm = &quot;rcu_par_gp\000\000\000\000\000&quot;,
ffff9dd30023b180
  comm = &quot;kworker/0:0H\000\000\000&quot;,
ffff9dd30023ca40
  comm = &quot;mm_percpu_wq\000\000\000&quot;,
ffff9dd3002398c0
  comm = &quot;rcu_tasks_kthre&quot;,
ffff9dd300266300
  comm = &quot;rcu_tasks_rude_&quot;,
ffff9dd300264a40

crash&gt;
</code></pre></div><p>普通进程的nice值是优先级. 用户态显示的范围为 [-20 ~ 19], 值越低,优先级越高.对应的task_struct的字段为static_prio, 取值为[100～139]</p><div class="language-c ext-c"><pre class="language-c"><code>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_NICE</span>	<span class="token expression"><span class="token number">19</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MIN_NICE</span>	<span class="token expression"><span class="token operator">-</span><span class="token number">20</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NICE_WIDTH</span>	<span class="token expression"><span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> MIN_NICE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Priority of a process goes from 0..MAX_PRIO-1, valid RT
 * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH
 * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority
 * values are inverted: lower p-&gt;prio value means higher priority.
 *
 * The MAX_USER_RT_PRIO value allows the actual maximum
 * RT priority to be separate from the value exported to
 * user-space.  This allows kernel threads to set their
 * priority to a value higher than any user task. Note:
 * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_RT_PRIO</span>	<span class="token expression"><span class="token number">100</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_RT_PRIO</span>		<span class="token expression">MAX_USER_RT_PRIO</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PRIO</span>		<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_PRIO</span>		<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Convert user-nice values [ -20 ... 0 ... 19 ]
 * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
 * and back.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NICE_TO_PRIO</span><span class="token expression"><span class="token punctuation">(</span>nice<span class="token punctuation">)</span>	<span class="token punctuation">(</span><span class="token punctuation">(</span>nice<span class="token punctuation">)</span> <span class="token operator">+</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRIO_TO_NICE</span><span class="token expression"><span class="token punctuation">(</span>prio<span class="token punctuation">)</span>	<span class="token punctuation">(</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span> <span class="token operator">-</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * &#39;User priority&#39; is the nice value converted to something we
 * can work with better when scaling various scheduler parameters,
 * it&#39;s a [ 0 ... 39 ] range.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>		<span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span>MAX_RT_PRIO<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TASK_USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>	<span class="token function">USER_PRIO</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_PRIO</span>		<span class="token expression"><span class="token punctuation">(</span><span class="token function">USER_PRIO</span><span class="token punctuation">(</span>MAX_PRIO<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Convert nice value [19,-20] to rlimit style value [1,40].
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">nice_to_rlimit</span><span class="token punctuation">(</span><span class="token keyword">long</span> nice<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> nice <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 * task_nice - return the nice value of a given task.
 * @p: the task in question.
 *
 * Return: The nice value [ -20 ... 0 ... 19 ].
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">task_nice</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">PRIO_TO_NICE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
```普通进程的nice值是优先级<span class="token punctuation">.</span> 用户态显示的范围为 <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">20</span> <span class="token operator">~</span> <span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 值越低<span class="token punctuation">,</span>优先级越高<span class="token punctuation">.</span>对应的task_struct的字段为static_prio<span class="token punctuation">,</span> 取值为<span class="token punctuation">[</span><span class="token number">100</span>～<span class="token number">139</span><span class="token punctuation">]</span>

``` c

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_NICE</span>	<span class="token expression"><span class="token number">19</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MIN_NICE</span>	<span class="token expression"><span class="token operator">-</span><span class="token number">20</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NICE_WIDTH</span>	<span class="token expression"><span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> MIN_NICE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Priority of a process goes from 0..MAX_PRIO-1, valid RT
 * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH
 * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority
 * values are inverted: lower p-&gt;prio value means higher priority.
 *
 * The MAX_USER_RT_PRIO value allows the actual maximum
 * RT priority to be separate from the value exported to
 * user-space.  This allows kernel threads to set their
 * priority to a value higher than any user task. Note:
 * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_RT_PRIO</span>	<span class="token expression"><span class="token number">100</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_RT_PRIO</span>		<span class="token expression">MAX_USER_RT_PRIO</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PRIO</span>		<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_PRIO</span>		<span class="token expression"><span class="token punctuation">(</span>MAX_RT_PRIO <span class="token operator">+</span> NICE_WIDTH <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Convert user-nice values [ -20 ... 0 ... 19 ]
 * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
 * and back.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NICE_TO_PRIO</span><span class="token expression"><span class="token punctuation">(</span>nice<span class="token punctuation">)</span>	<span class="token punctuation">(</span><span class="token punctuation">(</span>nice<span class="token punctuation">)</span> <span class="token operator">+</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRIO_TO_NICE</span><span class="token expression"><span class="token punctuation">(</span>prio<span class="token punctuation">)</span>	<span class="token punctuation">(</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span> <span class="token operator">-</span> DEFAULT_PRIO<span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * &#39;User priority&#39; is the nice value converted to something we
 * can work with better when scaling various scheduler parameters,
 * it&#39;s a [ 0 ... 39 ] range.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>		<span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-</span>MAX_RT_PRIO<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TASK_USER_PRIO</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span>	<span class="token function">USER_PRIO</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_USER_PRIO</span>		<span class="token expression"><span class="token punctuation">(</span><span class="token function">USER_PRIO</span><span class="token punctuation">(</span>MAX_PRIO<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/*
 * Convert nice value [19,-20] to rlimit style value [1,40].
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">long</span> <span class="token function">nice_to_rlimit</span><span class="token punctuation">(</span><span class="token keyword">long</span> nice<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>MAX_NICE <span class="token operator">-</span> nice <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 * task_nice - return the nice value of a given task.
 * @p: the task in question.
 *
 * Return: The nice value [ -20 ... 0 ... 19 ].
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">task_nice</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">PRIO_TO_NICE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>static_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="调度细节" tabindex="-1"><a class="header-anchor" href="#调度细节" aria-hidden="true">#</a> 调度细节</h2><p>linux支持的调度策略如下</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token comment">/*
 * The order of the sched class addresses are important, as they are
 * used to determine the order of the priority of each sched class in
 * relation to each other.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_DATA</span>				<span class="token punctuation">\</span>
	<span class="token expression"><span class="token function">STRUCT_ALIGN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				</span><span class="token punctuation">\</span>
	<span class="token expression">__begin_sched_classes <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">;</span>		</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__idle_sched_class<span class="token punctuation">)</span>			</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__fair_sched_class<span class="token punctuation">)</span>			</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__rt_sched_class<span class="token punctuation">)</span>			</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__dl_sched_class<span class="token punctuation">)</span>			</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>__stop_sched_class<span class="token punctuation">)</span>			</span><span class="token punctuation">\</span>
	<span class="token expression">__end_sched_classes <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">;</span></span></span>

</code></pre></div><p>struct rq.clock 的单位是ns, cfs里<code>update_curr</code>用于更新进程运行时的统计量</p><p>分两种情况:</p><ol><li>主动式调度 当写IO,或者等待其他资源时,主动让出cpu的, 代码中直接调用<code>__schedule</code></li><li>被动式调度 <ul><li>自身时间执行时间过长,占用cpu过多, 调度管理会通过时钟中断调用<code>scheduler_tick</code>更新进程相关的统计信息, 判断是否需要重新调度. 如果时,则将该进程标记为<code>_TIF_NEED_RESCHED</code><ul><li>curr-&gt;sched_class-&gt;task_tick(rq, curr, 0) 里调用 entity_tick()</li><li>entity_tick() 调用 update_curr 更新当前进程 vruntime, 调用 check_preempt_tick 检测是否需要被调度</li><li>check_preempt_tick 中判断已运行的是否是否大于ideal_runtime(估算的进程应该运行的时间), 当前进程的vruntime和队列里最小的vruntime, 如果超过阈值,说明有其他进程更需要运行.</li></ul></li><li>被刚刚唤醒的进程,如果优先级更高,也会标记为<code>_TIF_NEED_RESCHED</code><ul><li>try_to_wake_up -&gt; ttwu_queue -&gt; ttwu_do_activate -&gt; activate_task 加入到可运行队列</li><li>try_to_wake_up -&gt; ttwu_queue -&gt; ttwu_do_activate -&gt; ttwu_do_wakeup 检查是否需要被调度</li></ul></li><li>抢占时机, 什么时候让已标记为<code>_TIF_NEED_RESCHED</code>的运行<code>__schedule</code>调出去 <ul><li>用户态进程 <ul><li>系统调用调用返回时,在<code>exit_to_user_mode_loop</code>里</li><li>中断返回时, irqentry_exit --&gt; irqentry_exit_to_user_mode --&gt; exit_to_user_mode_prepare --&gt; exit_to_user_mode_loop</li></ul></li><li>内核态进程 如果没有配置<code>CONFIG_PREEMPT=y</code>, 那么内核态运行时无法抢占, 假设该功能打开则: <ul><li>中断返回时,irqentry_exit --&gt; irqentry_exit_cond_resched --&gt; preempt_schedule_irq</li><li>preempt_disable在某些路径关闭抢占后, 用preempt_enable打开时可能执行<code>__schedule</code></li></ul></li><li>正是因为主流的linux发行版不支持内核抢占,所以系统调用运行时间过长会导致应用程序处理延迟,因为一直要等到临近返回用户态时才主动调度出去</li></ul></li></ul></li></ol><p>无论主动还是被动, 都会通过<code>schedule</code>把进程切出去, schedule --&gt; __schedule --&gt; context_switch --&gt; switch_to --&gt; __switch_to_asm --&gt;</p><div class="language-c ext-c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">switch_to</span><span class="token expression"><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>					</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>									</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">__switch_to_asm</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre></div><div class="language-c ext-c"><pre class="language-c"><code><span class="token function">SYM_FUNC_START</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>
	<span class="token comment">/*
	 * Save callee-saved registers
	 * This must match the order in inactive_task_frame
	 */</span>
	pushq	<span class="token operator">%</span>rbp
	pushq	<span class="token operator">%</span>rbx
	pushq	<span class="token operator">%</span>r12
	pushq	<span class="token operator">%</span>r13
	pushq	<span class="token operator">%</span>r14
	pushq	<span class="token operator">%</span>r15

	<span class="token comment">/* switch stack */</span>
	movq	<span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span>
	movq	<span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>rsi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp    
	<span class="token comment">/* 执行完这个命令之后, 后续操作都是在next这个进程的内核栈进行了 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_STACKPROTECTOR</span></span>
	movq	<span class="token function">TASK_stack_canary</span><span class="token punctuation">(</span><span class="token operator">%</span>rsi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rbx
	movq	<span class="token operator">%</span>rbx<span class="token punctuation">,</span> <span class="token function">PER_CPU_VAR</span><span class="token punctuation">(</span>fixed_percpu_data<span class="token punctuation">)</span> <span class="token operator">+</span> stack_canary_offset
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_RETPOLINE</span></span>
	<span class="token comment">/*
	 * When switching from a shallower to a deeper call stack
	 * the RSB may either underflow or use entries populated
	 * with userspace addresses. On CPUs where those concerns
	 * exist, overwrite the RSB with entries which capture
	 * speculative execution to prevent attack.
	 */</span>
	FILL_RETURN_BUFFER <span class="token operator">%</span>r12<span class="token punctuation">,</span> RSB_CLEAR_LOOPS<span class="token punctuation">,</span> X86_FEATURE_RSB_CTXSW
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

	<span class="token comment">/* restore callee-saved registers */</span>
	popq	<span class="token operator">%</span>r15
	popq	<span class="token operator">%</span>r14
	popq	<span class="token operator">%</span>r13
	popq	<span class="token operator">%</span>r12
	popq	<span class="token operator">%</span>rbx
	popq	<span class="token operator">%</span>rbp

	jmp	__switch_to
<span class="token function">SYM_FUNC_END</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>
</code></pre></div><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">7/10/2022, 3:49:18 PM</span></div><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/kernel/kernel-memory.html" class="nav-link" aria-label="内存管理"><!--[--><!--]--> 内存管理 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.443127ae.js" defer></script><script src="/assets/js/838.91c535db.js" defer></script><script src="/assets/js/app.1ace75fc.js" defer></script>
  </body>
</html>
